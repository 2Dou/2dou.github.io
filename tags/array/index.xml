<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Array on Orz the way</title>
    <link>https://www.orztu.com/tags/array/</link>
    <description>Recent content in Array on Orz the way</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 05 Dec 2018 11:03:48 +0800</lastBuildDate>
    
	<atom:link href="https://www.orztu.com/tags/array/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LeetCode 78. Subsets</title>
      <link>https://www.orztu.com/leetcode/078-subsets/</link>
      <pubDate>Wed, 05 Dec 2018 11:03:48 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/078-subsets/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/subsets/&#34; target=&#34;_blank&#34;&gt;Subsets&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a set of distinct integers, nums, return all possible subsets (the power set).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The solution set must not contain duplicate subsets.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;求所有子集（幂集），包含一个空集。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 75. Sort Colors</title>
      <link>https://www.orztu.com/leetcode/075-sort-colors/</link>
      <pubDate>Thu, 29 Nov 2018 10:50:23 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/075-sort-colors/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/sort-colors/&#34; target=&#34;_blank&#34;&gt;Sort Colors&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.&lt;/p&gt;

&lt;p&gt;Here, we will use the integers &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;2&lt;/code&gt; to represent the color &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;white&lt;/code&gt;, and &lt;code&gt;blue&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; You are not suppose to use the library&amp;rsquo;s sort function for this problem.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
Follow up:
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A rather straight forward solution is a two-pass algorithm using counting sort.&lt;br&gt;
First, iterate the array counting number of 0&amp;rsquo;s, 1&amp;rsquo;s, and 2&amp;rsquo;s, then overwrite array with total number of 0&amp;rsquo;s, then 1&amp;rsquo;s and followed by 2&amp;rsquo;s.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Could you come up with a one-pass algorithm using only constant space?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;对一个只包含&lt;code&gt;0&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;2&lt;/code&gt;三个数字的数组进行排序，要求时间复杂度&lt;code&gt;O(n)&lt;/code&gt;，空间复杂度&lt;code&gt;O(1)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 74. Search a 2D Matrix</title>
      <link>https://www.orztu.com/leetcode/074-search-a-2d-matrix/</link>
      <pubDate>Wed, 28 Nov 2018 15:07:51 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/074-search-a-2d-matrix/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-a-2d-matrix/&#34; target=&#34;_blank&#34;&gt;Search a 2D Matrix&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Integers in each row are sorted from left to right.&lt;/li&gt;
&lt;li&gt;The first integer of each row is greater than the last integer of the previous row.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]

target = 3
Output: true

target = 13
Output: false
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;矩阵中有序存地放着一些数字，查找是否存在某个数字。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 73. Set Matrix Zeroes</title>
      <link>https://www.orztu.com/leetcode/073-set-matrix-zeroes/</link>
      <pubDate>Wed, 28 Nov 2018 14:33:12 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/073-set-matrix-zeroes/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/set-matrix-zeroes/&#34; target=&#34;_blank&#34;&gt;Set Matrix Zeroes&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a m x n matrix, if an element is &lt;code&gt;0&lt;/code&gt;, set its entire row and column to 0. Do it in-place.
&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input:
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output:
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input:
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output:
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A straight forward solution using O(mn) space is probably a bad idea.&lt;/li&gt;
&lt;li&gt;A simple improvement uses O(m + n) space, but still not the best solution.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Could you devise a constant space solution?&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;在&lt;code&gt;m x n&lt;/code&gt;的矩阵中，如果一个元素为&lt;code&gt;0&lt;/code&gt;，则将它所在的行和列都置为&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 66. Plus One &amp; 67. Add Binary</title>
      <link>https://www.orztu.com/leetcode/066-and-067/</link>
      <pubDate>Fri, 23 Nov 2018 09:54:07 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/066-and-067/</guid>
      <description>&lt;h2 id=&#34;plus-one&#34;&gt;Plus One&lt;/h2&gt;

&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/plus-one/&#34; target=&#34;_blank&#34;&gt;Plus One&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;给定一个用数组表示的十进制数，将数字加一。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 64. Minimum Path Sum</title>
      <link>https://www.orztu.com/leetcode/064-minimum-path-sum/</link>
      <pubDate>Thu, 22 Nov 2018 14:44:37 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/064-minimum-path-sum/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/minimum-path-sum/&#34; target=&#34;_blank&#34;&gt;Minimum Path Sum&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; You can only move either down or right at any point in time.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;每个格子的数字表示经过它所需的消耗大小。寻找从左上到右下的最少路径消耗。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 63. Unique Paths II</title>
      <link>https://www.orztu.com/leetcode/063-unique-paths-ii/</link>
      <pubDate>Thu, 22 Nov 2018 09:06:11 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/063-unique-paths-ii/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/unique-paths-ii/&#34; target=&#34;_blank&#34;&gt;Unique Paths II&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below).&lt;/p&gt;

&lt;p&gt;The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below).&lt;/p&gt;

&lt;p&gt;Now consider if some obstacles are added to the grids. How many unique paths would there be?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.orztu.com/images/leetcode/062-unique-paths-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;An obstacle and empty space is marked as 1 and 0 respectively in the grid.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; m and n will be at most 100.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -&amp;gt; Right -&amp;gt; Down -&amp;gt; Down
2. Down -&amp;gt; Down -&amp;gt; Right -&amp;gt; Right
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;给出地图，求左上角到右下角的路径数量（只能向下或向右移动）。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 59. Spiral Matrix II</title>
      <link>https://www.orztu.com/leetcode/059-spiral-matrix-ii/</link>
      <pubDate>Fri, 16 Nov 2018 08:54:44 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/059-spiral-matrix-ii/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/spiral-matrix-ii/&#34; target=&#34;_blank&#34;&gt;Spiral Matrix II&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a positive integer n, generate a square matrix filled with elements from 1 to n^2 in spiral order.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: 3
Output:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 57. Insert Interval</title>
      <link>https://www.orztu.com/leetcode/057-insert-interval/</link>
      <pubDate>Thu, 15 Nov 2018 16:31:58 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/057-insert-interval/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/insert-interval&#34; target=&#34;_blank&#34;&gt;Insert Interval&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).&lt;/p&gt;

&lt;p&gt;You may assume that the intervals were initially sorted according to their start times.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;在给出的有序区间中插入新的区间，需要合并相邻的区间。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 56. Merge Intervals</title>
      <link>https://www.orztu.com/leetcode/056-merge-intervals/</link>
      <pubDate>Thu, 15 Nov 2018 14:49:19 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/056-merge-intervals/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/merge-intervals&#34; target=&#34;_blank&#34;&gt;Merge Intervals&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a collection of intervals, merge all overlapping intervals.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considerred overlapping.
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;合并区间重叠/相邻的区间。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 55. Jump Game</title>
      <link>https://www.orztu.com/leetcode/055-jump-game/</link>
      <pubDate>Thu, 15 Nov 2018 11:29:11 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/055-jump-game/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/jump-game/&#34; target=&#34;_blank&#34;&gt;Jump Game&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given an array of non-negative integers, you are initially positioned at the first index of the array.&lt;/p&gt;

&lt;p&gt;Each element in the array represents your maximum jump length at that position.&lt;/p&gt;

&lt;p&gt;Determine if you are able to reach the last index.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;给定一个非负整型数组，每个数字表示可以从该位置向后跳跃的最大步数。&lt;/p&gt;

&lt;p&gt;判断是否能从第一个数字开始跳跃到最后一个数字。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 54. Spiral Matrix</title>
      <link>https://www.orztu.com/leetcode/054-spiral-matrix/</link>
      <pubDate>Thu, 15 Nov 2018 10:43:41 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/054-spiral-matrix/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/spiral-matrix/&#34; target=&#34;_blank&#34;&gt;Spiral Matrix&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1,2,3,6,9,8,7,4,5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;从外向内螺旋形遍历矩阵。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 62. Unique Paths</title>
      <link>https://www.orztu.com/leetcode/062-unique-paths/</link>
      <pubDate>Mon, 10 Sep 2018 14:43:03 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/062-unique-paths/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/unique-paths/&#34; target=&#34;_blank&#34;&gt;Unique Paths&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below).&lt;/p&gt;

&lt;p&gt;The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below).&lt;/p&gt;

&lt;p&gt;How many possible unique paths are there?
&lt;img src=&#34;https://www.orztu.com/images/leetcode/062-unique-paths-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 41. First Missing Positive</title>
      <link>https://www.orztu.com/leetcode/041-first-missing-positive/</link>
      <pubDate>Fri, 27 Jul 2018 08:59:07 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/041-first-missing-positive/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/first-missing-positive/&#34; target=&#34;_blank&#34;&gt;First Missing Positive&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Given an unsorted integer array, find the smallest missing positive integer.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [1,2,0]
Output: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [3,4,-1,1]
Output: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [7,8,9,11,12]
Output: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Your algorithm should run in O(n) time and uses constant extra space.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用&lt;code&gt;O(n)&lt;/code&gt;的时间复杂度和&lt;code&gt;O(1)&lt;/code&gt;的空间在无序数组中查找第一个缺失的正数。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 40. Combination Sum II</title>
      <link>https://www.orztu.com/leetcode/040-combination-sum-ii/</link>
      <pubDate>Thu, 26 Jul 2018 10:39:33 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/040-combination-sum-ii/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum-ii/&#34; target=&#34;_blank&#34;&gt;Combination Sum II&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a collection of candidate numbers (&lt;code&gt;candidates&lt;/code&gt;) and a target number (&lt;code&gt;target&lt;/code&gt;), find all unique combinations in candidates where the &lt;code&gt;candidate&lt;/code&gt; numbers sums to &lt;code&gt;target&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Each number in &lt;code&gt;candidates&lt;/code&gt; may only be used once in the combination.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;All numbers (including &lt;code&gt;target&lt;/code&gt;) will be positive integers.
The solution set must not contain duplicate combinations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 39. Combination Sum</title>
      <link>https://www.orztu.com/leetcode/039-combination-sum/</link>
      <pubDate>Thu, 26 Jul 2018 10:16:53 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/039-combination-sum/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum/&#34; target=&#34;_blank&#34;&gt;Combination Sum&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a set of candidate numbers (&lt;code&gt;candidates&lt;/code&gt;) (without duplicates) and a target number (&lt;code&gt;target&lt;/code&gt;), find all unique combinations in &lt;code&gt;candidates&lt;/code&gt; where the candidate numbers sums to &lt;code&gt;target&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;same&lt;/strong&gt; repeated number may be chosen from candidates unlimited number of times.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;All numbers (including &lt;code&gt;target&lt;/code&gt;) will be positive integers.&lt;/li&gt;
&lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 33. Search in Rotated Sorted Array</title>
      <link>https://www.orztu.com/leetcode/033-search-in-rotated-sorted-array/</link>
      <pubDate>Wed, 25 Jul 2018 14:28:45 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/033-search-in-rotated-sorted-array/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-in-rotated-sorted-array/&#34; target=&#34;_blank&#34;&gt;Search in Rotated Sorted Array&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;/p&gt;

&lt;p&gt;(i.e., &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; might become &lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;You are given a target value to search. If found in the array return its index, otherwise return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You may assume no duplicate exists in the array.&lt;/p&gt;

&lt;p&gt;Your algorithm&amp;rsquo;s runtime complexity must be in the order of &lt;code&gt;O(log n)&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 31. Next Permutation</title>
      <link>https://www.orztu.com/leetcode/031-next-permutation/</link>
      <pubDate>Thu, 19 Jul 2018 10:17:07 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/031-next-permutation/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/next-permutation/&#34; target=&#34;_blank&#34;&gt;Next Permutation&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.&lt;/p&gt;

&lt;p&gt;If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).&lt;/p&gt;

&lt;p&gt;The replacement must be in-place and use only constant extra memory.&lt;/p&gt;

&lt;p&gt;Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1,2,3&lt;/code&gt; → &lt;code&gt;1,3,2&lt;/code&gt;&lt;br&gt;
&lt;code&gt;3,2,1&lt;/code&gt; → &lt;code&gt;1,2,3&lt;/code&gt;&lt;br&gt;
&lt;code&gt;1,1,5&lt;/code&gt; → &lt;code&gt;1,5,1&lt;/code&gt;&lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;实现字典序排列的 nextPermutation 方法，假如已经是最大排列，则输出最小排列。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 18. 4Sum</title>
      <link>https://www.orztu.com/leetcode/018-4sum/</link>
      <pubDate>Tue, 17 Oct 2017 16:27:33 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/018-4sum/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/4sum/&#34; target=&#34;_blank&#34;&gt;4Sum&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: The solution set must not contain duplicate quadruplets.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;在给定数组中找出“和为 target 的四个数”的所有解。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 15. 3Sum</title>
      <link>https://www.orztu.com/leetcode/015-3sum/</link>
      <pubDate>Fri, 28 Jul 2017 08:54:12 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/015-3sum/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/3sum/&#34; target=&#34;_blank&#34;&gt;3Sum&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The solution set must not contain duplicate triplets.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;For example, given array S = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;在给定数组中找出“和为0的三个数”的所有解。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 11. Container With Most Water</title>
      <link>https://www.orztu.com/leetcode/011-container-with-most-water/</link>
      <pubDate>Thu, 06 Jul 2017 14:09:43 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/011-container-with-most-water/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/container-with-most-water/&#34; target=&#34;_blank&#34;&gt;Container With Most Water&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Given n non-negative integers a1, a2, &amp;hellip;, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.&lt;br&gt;
&lt;br&gt;
Note: You may not slant the container and n is at least 2.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;给出n个点，它们与X轴有n条垂线，每两条垂线与X轴形成的U型容器，找出最大“容积”(面积）&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 42. Trapping Rain Water</title>
      <link>https://www.orztu.com/leetcode/042-trapping-rain-water/</link>
      <pubDate>Fri, 28 Apr 2017 10:01:32 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/042-trapping-rain-water/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/trapping-rain-water/&#34; target=&#34;_blank&#34;&gt;Trapping Rain Water&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how &amp;gt;much water it is able to trap after raining.&lt;/p&gt;

&lt;p&gt;For example,
Given &lt;code&gt;[0,1,0,2,1,0,1,3,2,1,2,1]&lt;/code&gt;, return &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.orztu.com/images/leetcode/rainwatertrap-1.png&#34; alt=&#34;palindromic&#34; /&gt;
The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 4. Median of Two Sorted Arrays</title>
      <link>https://www.orztu.com/leetcode/004-median-of-two-sorted-arrays/</link>
      <pubDate>Thu, 16 Mar 2017 10:53:58 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/004-median-of-two-sorted-arrays/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/median-of-two-sorted-arrays&#34; target=&#34;_blank&#34;&gt;Median of Two Sorted Arrays&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;There are two sorted arrays nums1 and nums2 of size m and n respectively.&lt;/p&gt;

&lt;p&gt;Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).&lt;/p&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nums1 = [1, 3]
nums2 = [2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The median is 2.0
Example 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nums1 = [1, 2]
nums2 = [3, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The median is (2 + 3)/2 = 2.5&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从两个有序数组中求中位数&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 1. Two Sum</title>
      <link>https://www.orztu.com/leetcode/001-two-sum/</link>
      <pubDate>Wed, 15 Mar 2017 16:36:59 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/001-two-sum/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/two-sum&#34; target=&#34;_blank&#34;&gt;Two Sum&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;/p&gt;

&lt;p&gt;You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Example:
Given nums = [2, 7, 11, 15], target = 9,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;假定只有&lt;strong&gt;唯一&lt;/strong&gt;解的情况下在数组中找出和为&lt;code&gt;target&lt;/code&gt;的两个数&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>