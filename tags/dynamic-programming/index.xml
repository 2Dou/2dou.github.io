<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dynamic Programming on Orz the way</title>
    <link>https://www.orztu.com/tags/dynamic-programming/</link>
    <description>Recent content in Dynamic Programming on Orz the way</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 30 Mar 2020 11:32:28 +0800</lastBuildDate>
    
	<atom:link href="https://www.orztu.com/tags/dynamic-programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LeetCode 96. Unique Binary Search Trees</title>
      <link>https://www.orztu.com/leetcode/096-unique-binary-search-trees/</link>
      <pubDate>Mon, 30 Mar 2020 11:32:28 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/096-unique-binary-search-trees/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/unique-binary-search-trees/&#34;&gt;Unique Binary Search Trees&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given n, how many structurally unique BST&#39;s (binary search trees) that store values 1 &amp;hellip; n?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: 3
Output: 5
Explanation:
Given n = 3, there are a total of 5 unique BST&#39;s:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 91. Decode Ways</title>
      <link>https://www.orztu.com/leetcode/091-decode-ways/</link>
      <pubDate>Wed, 30 Jan 2019 17:19:21 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/091-decode-ways/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/decode-ways/&#34;&gt;Decode Ways&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A message containing letters from A-Z is being encoded to numbers using the following mapping:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&#39;A&#39; -&amp;gt; 1
&#39;B&#39; -&amp;gt; 2
...
&#39;Z&#39; -&amp;gt; 26
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Given a &lt;strong&gt;non-empty&lt;/strong&gt; string containing only digits, determine the total number of ways to decode it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;Input: &amp;quot;12&amp;quot;
Output: 2
Explanation: It could be decoded as &amp;quot;AB&amp;quot; (1 2) or &amp;quot;L&amp;quot; (12).
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;Input: &amp;quot;226&amp;quot;
Output: 3
Explanation: It could be decoded as &amp;quot;BZ&amp;quot; (2 26), &amp;quot;VF&amp;quot; (22 6), or &amp;quot;BBF&amp;quot; (2 2 6).
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 87. Scramble String</title>
      <link>https://www.orztu.com/leetcode/087-scramble-string/</link>
      <pubDate>Thu, 03 Jan 2019 09:14:13 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/087-scramble-string/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/scramble-string/&#34;&gt;Scramble String&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.&lt;/p&gt;
&lt;p&gt;Below is one possible representation of s1 = &lt;code&gt;&amp;quot;great&amp;quot;&lt;/code&gt;:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;To scramble the string, we may choose any non-leaf node and swap its two children.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 85. Maximal Rectangle</title>
      <link>https://www.orztu.com/leetcode/085-maximal-rectangle/</link>
      <pubDate>Wed, 12 Dec 2018 11:42:17 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/085-maximal-rectangle/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/maximal-rectangle/&#34;&gt;Maximal Rectangle&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a 2D binary matrix filled with 0&#39;s and 1&#39;s, find the largest rectangle containing only 1&#39;s and return its area.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;Input:
[
  [&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],
  [&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;],
  [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;],
  [&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;]
]
Output: 6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在给出的矩阵中，&lt;code&gt;1&lt;/code&gt;表示元素，&lt;code&gt;0&lt;/code&gt;表示空，找出最大矩形的面积。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 72. Edit Distance</title>
      <link>https://www.orztu.com/leetcode/072-edit-distance/</link>
      <pubDate>Tue, 27 Nov 2018 10:51:41 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/072-edit-distance/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/edit-distance/&#34;&gt;Edit Distance&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.&lt;/p&gt;
&lt;p&gt;You have the following 3 operations permitted on a word:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Insert a character&lt;/li&gt;
&lt;li&gt;Delete a character&lt;/li&gt;
&lt;li&gt;Replace a character&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;Input: word1 = &amp;ldquo;horse&amp;rdquo;, word2 = &amp;ldquo;ros&amp;rdquo;
Output: 3
Explanation:
horse -&amp;gt; rorse (replace &amp;lsquo;h&amp;rsquo; with &amp;lsquo;r&amp;rsquo;)
rorse -&amp;gt; rose (remove &amp;lsquo;r&amp;rsquo;)
rose -&amp;gt; ros (remove &amp;lsquo;e&amp;rsquo;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;
&amp;gt; **Example 2:**
&amp;gt;
&amp;gt; ```
Input: word1 = &amp;quot;intention&amp;quot;, word2 = &amp;quot;execution&amp;quot;
Output: 5
Explanation:
intention -&amp;gt; inention (remove &#39;t&#39;)
inention -&amp;gt; enention (replace &#39;i&#39; with &#39;e&#39;)
enention -&amp;gt; exention (replace &#39;n&#39; with &#39;x&#39;)
exention -&amp;gt; exection (replace &#39;n&#39; with &#39;c&#39;)
exection -&amp;gt; execution (insert &#39;u&#39;)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 70. Climbing Stairs</title>
      <link>https://www.orztu.com/leetcode/070-climbing-stairs/</link>
      <pubDate>Mon, 26 Nov 2018 09:11:58 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/070-climbing-stairs/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/climbing-stairs/&#34;&gt;Climbing Stairs&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;/p&gt;
&lt;p&gt;Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Given n will be a positive integer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;好像网上讲动态规划经常举例的题目。&lt;/p&gt;
&lt;p&gt;爬楼梯，可以一次爬一格或者两格，问有多少种不同的方式爬到顶。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 64. Minimum Path Sum</title>
      <link>https://www.orztu.com/leetcode/064-minimum-path-sum/</link>
      <pubDate>Thu, 22 Nov 2018 14:44:37 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/064-minimum-path-sum/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/minimum-path-sum/&#34;&gt;Minimum Path Sum&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; You can only move either down or right at any point in time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;每个格子的数字表示经过它所需的消耗大小。寻找从左上到右下的最少路径消耗。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 63. Unique Paths II</title>
      <link>https://www.orztu.com/leetcode/063-unique-paths-ii/</link>
      <pubDate>Thu, 22 Nov 2018 09:06:11 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/063-unique-paths-ii/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/unique-paths-ii/&#34;&gt;Unique Paths II&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below).&lt;/p&gt;
&lt;p&gt;The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below).&lt;/p&gt;
&lt;p&gt;Now consider if some obstacles are added to the grids. How many unique paths would there be?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.orztu.com/images/leetcode/062-unique-paths-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;An obstacle and empty space is marked as 1 and 0 respectively in the grid.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; m and n will be at most 100.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -&amp;gt; Right -&amp;gt; Down -&amp;gt; Down
2. Down -&amp;gt; Down -&amp;gt; Right -&amp;gt; Right
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;给出地图，求左上角到右下角的路径数量（只能向下或向右移动）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 62. Unique Paths</title>
      <link>https://www.orztu.com/leetcode/062-unique-paths/</link>
      <pubDate>Mon, 10 Sep 2018 14:43:03 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/062-unique-paths/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/unique-paths/&#34;&gt;Unique Paths&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below).&lt;/p&gt;
&lt;p&gt;The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below).&lt;/p&gt;
&lt;p&gt;How many possible unique paths are there?
&lt;img src=&#34;https://www.orztu.com/images/leetcode/062-unique-paths-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 32. Longest Valid Parentheses</title>
      <link>https://www.orztu.com/leetcode/032-longest-valid-parentheses/</link>
      <pubDate>Wed, 25 Jul 2018 09:56:49 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/032-longest-valid-parentheses/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-valid-parentheses/&#34;&gt;Longest Valid Parentheses&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a string containing just the characters &lt;code&gt;&#39;(&#39;&lt;/code&gt; and &lt;code&gt;&#39;)&#39;&lt;/code&gt;, find the length of the longest valid (well-formed) parentheses substring.
&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;
&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: &amp;quot;(()&amp;quot;
Output: 2
Explanation: The longest valid parentheses substring is &amp;quot;()&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出最长的左右括号匹配的子串长度&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 10. Regular Expression Matching</title>
      <link>https://www.orztu.com/leetcode/010-regular-expression-matching/</link>
      <pubDate>Fri, 24 Mar 2017 15:00:47 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/010-regular-expression-matching/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/regular-expression-matching&#34;&gt;Regular Expression Matching&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Implement regular expression matching with support for &amp;lsquo;.&amp;rsquo; and &amp;lsquo;*&#39;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;.&#39; Matches any single character.
&#39;*&#39; Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch(&amp;quot;aa&amp;quot;,&amp;quot;a&amp;quot;) → false
isMatch(&amp;quot;aa&amp;quot;,&amp;quot;aa&amp;quot;) → true
isMatch(&amp;quot;aaa&amp;quot;,&amp;quot;aa&amp;quot;) → false
isMatch(&amp;quot;aa&amp;quot;, &amp;quot;a*&amp;quot;) → true
isMatch(&amp;quot;aa&amp;quot;, &amp;quot;.*&amp;quot;) → true
isMatch(&amp;quot;ab&amp;quot;, &amp;quot;.*&amp;quot;) → true
isMatch(&amp;quot;aab&amp;quot;, &amp;quot;c*a*b&amp;quot;) → true
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 5. Longest Palindromic Substring</title>
      <link>https://www.orztu.com/leetcode/005-longest-palindromic-substring/</link>
      <pubDate>Thu, 16 Mar 2017 14:47:07 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/005-longest-palindromic-substring/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-palindromic-substring&#34;&gt;Longest Palindromic Substring&lt;/a&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;Input: &amp;quot;babad&amp;quot;
Output: &amp;quot;bab&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Note: &amp;ldquo;aba&amp;rdquo; is also a valid answer.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;Input: &amp;quot;cbbd&amp;quot;
Output: &amp;quot;bb&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从给定字符串中找出最长的回文子串&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>