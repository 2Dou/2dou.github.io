<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Regular on Orz the way</title>
    <link>http://www.orztu.com/tags/regular/index.xml</link>
    <description>Recent content in Regular on Orz the way</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="http://www.orztu.com/tags/regular/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>10. Regular Expression Matching</title>
      <link>http://www.orztu.com/leetcode/Regular-Expression-Matching/</link>
      <pubDate>Fri, 24 Mar 2017 15:00:47 +0800</pubDate>
      
      <guid>http://www.orztu.com/leetcode/Regular-Expression-Matching/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/regular-expression-matching&#34; target=&#34;_blank&#34;&gt;Regular Expression Matching&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Implement regular expression matching with support for &amp;lsquo;.&amp;rsquo; and &amp;lsquo;*&amp;lsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;.&#39; Matches any single character.
&#39;*&#39; Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch(&amp;quot;aa&amp;quot;,&amp;quot;a&amp;quot;) → false
isMatch(&amp;quot;aa&amp;quot;,&amp;quot;aa&amp;quot;) → true
isMatch(&amp;quot;aaa&amp;quot;,&amp;quot;aa&amp;quot;) → false
isMatch(&amp;quot;aa&amp;quot;, &amp;quot;a*&amp;quot;) → true
isMatch(&amp;quot;aa&amp;quot;, &amp;quot;.*&amp;quot;) → true
isMatch(&amp;quot;ab&amp;quot;, &amp;quot;.*&amp;quot;) → true
isMatch(&amp;quot;aab&amp;quot;, &amp;quot;c*a*b&amp;quot;) → true
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;简单的字符匹配&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;


  
    
  
  
    
  
  
  


&lt;figure class=&#34;highlight go&#34;&gt;
  &lt;figcaption&gt;
    
      &lt;span&gt;My Solution&lt;/span&gt;
    
  &lt;/figcaption&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td class=&#34;gutter&#34;&gt;
          &lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;46&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;
        &lt;/td&gt;
        &lt;td class=&#34;code&#34;&gt;
          &lt;pre class=&#34;go code-highlight&#34;&gt;func isMatch(s string, p string) bool {
    if len(s) == 0 &amp;amp;&amp;amp; len(p) == 0 {
        return true
    } else if len(p) == 0 {
        // p is empty but s
        return false
    }

    matchChar := p[0]

    if len(p) &amp;gt; 1 &amp;amp;&amp;amp; p[1] == &amp;#39;*&amp;#39; {
        // match any numbers of char(s)

        // eat two char of p
        p = p[2:]

        for len(s) &amp;gt; 0{
            if s[0] == matchChar || matchChar == &amp;#39;.&amp;#39; {
                // try not to eat char of s
                if isMatch(s, p) {
                    return true
                }

                // let&amp;#39;s eat one char of s and try again
                s = s[1:]
            } else {
                break
            }
        }
    } else {
        // match one char

        // eat one char of p
        p = p[1:]

        // does it match?
        if len(s) == 0 || (s[0] != matchChar &amp;amp;&amp;amp; matchChar != &amp;#39;.&amp;#39;) {
            return false
        }

        // eat one char of s
        s = s[1:]
    }

    return isMatch(s, p)
}&lt;/pre&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/figure&gt;</description>
    </item>
    
  </channel>
</rss>