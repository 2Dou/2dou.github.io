<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tree on Orz the way</title>
    <link>https://www.orztu.com/tags/tree/</link>
    <description>Recent content in Tree on Orz the way</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 01 Apr 2020 17:20:18 +0800</lastBuildDate><atom:link href="https://www.orztu.com/tags/tree/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode 98. Validate Binary Search Tree</title>
      <link>https://www.orztu.com/leetcode/098-validate-binary-search-tree/</link>
      <pubDate>Wed, 01 Apr 2020 17:20:18 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/098-validate-binary-search-tree/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;link&#34;&gt;Title&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a binary tree, determine if it is a valid binary search tree (BST).&lt;/p&gt;
&lt;p&gt;Assume a BST is defined as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The left subtree of a node contains only nodes with keys less than the node&amp;rsquo;s key.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The right subtree of a node contains only nodes with keys greater than the node&amp;rsquo;s key.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Both the left and right subtrees must also be binary search trees.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   2
  / \
 1   3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [2,1,3]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt; true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;    5
   / \
  1   4
     / \
    3   6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; [5,1,4,null,null,3,6]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt; false&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt; The root node&amp;rsquo;s value is 5 but its right child&amp;rsquo;s value is 4.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 96. Unique Binary Search Trees</title>
      <link>https://www.orztu.com/leetcode/096-unique-binary-search-trees/</link>
      <pubDate>Mon, 30 Mar 2020 11:32:28 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/096-unique-binary-search-trees/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/unique-binary-search-trees/&#34;&gt;Unique Binary Search Trees&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given n, how many structurally unique BST&amp;rsquo;s (binary search trees) that store values 1 &amp;hellip; n?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; 3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt; 5&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;
Given n = 3, there are a total of 5 unique BST&amp;rsquo;s:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>LeetCode 94. Binary Tree Inorder Traversal</title>
      <link>https://www.orztu.com/leetcode/094-binary-tree-inorder-traversal/</link>
      <pubDate>Thu, 26 Mar 2020 11:18:43 +0800</pubDate>
      
      <guid>https://www.orztu.com/leetcode/094-binary-tree-inorder-traversal/</guid>
      <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/binary-tree-inorder-traversal/&#34;&gt;Binary Tree Inorder Traversal&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a binary tree, return the inorder traversal of its nodes&#39; values.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt; Recursive solution is trivial, could you do it iteratively?&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
  </channel>
</rss>
