[{"content":"Git 最近切换到 Windows 工作，使用 WSL 作为命令行方案。但在 WSL 里面安装 git 后，在工程里面执行命令时，总感觉非常缓慢。\n执行一下 git status 都要卡好一会儿。\n经过一番搜索，原因大概是 Windows 的路径索引到 WSL 之间有一个转换导致的？具体没有细看。\n但找到一个解决方案：\n先在 Windows 中安装 Git，然后在 WSL 里面用 git.exe 替代 Linux 版本的 git。\n因为我使用的oh-my-zsh，所以通过在.zshrc中定义git函数针对 WSL 路径和 Windows 路径区别处理（这个代码是抄的）：\n1 2 3 4 5 6 7 function git() { if $(pwd -P | grep -q \u0026#34;^\\/mnt\\/.\\/*\u0026#34;); then git.exe \u0026#34;$@\u0026#34; else command git \u0026#34;$@\u0026#34; fi } 但这样做需要注意两个环境的.gitconfig不是共用的。\n可以配置includeIf，通过匹配 gitdir， 在 WSL 里面引用 Windows 的 .gitconfig；又在 Windows 里面引用 WSL 的 .gitconfig。\n其它 然后依葫芦画瓢:\n在 WSL 中以用 Windows 环境打开 VS Code (如果是用 code 命令，打开的是 WSL 环境下的)：\n1 2 3 function code_win() { cmd.exe /c code.cmd $(wslpath -w \u0026#34;$@\u0026#34;) } 用 open 打开资源管理器：\n1 2 3 4 function open() { explorer.exe $(wslpath -w \u0026#34;$@\u0026#34;) return 0 } ","date":"2020-12-25T10:37:10+08:00","permalink":"https://www.orztu.com/post/wsl-command/","title":"Git is very slow in WSL"},{"content":"Description Title\nGiven a binary tree, determine if it is a valid binary search tree (BST).\nAssume a BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key.\nThe right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\n1 2 3 2 / \\ 1 3 Input: [2,1,3]\nOutput: true\nExample 2:\n1 2 3 4 5 5 / \\ 1 4 / \\ 3 6 Input: [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node\u0026rsquo;s value is 5 but its right child\u0026rsquo;s value is 4.\n验证二叉搜索树。\nSolution 中序遍历时，val应当有序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: bool isValidBST(TreeNode* root) { if (!root) { return true; } long first = LONG_MIN; return visit(root, first); } private: bool visit(TreeNode* root, long \u0026amp;last) { if (root-\u0026gt;left \u0026amp;\u0026amp; !visit(root-\u0026gt;left, last)) { return false; } if (root-\u0026gt;val \u0026lt;= last) { return false; } last = root-\u0026gt;val; if (root-\u0026gt;right \u0026amp;\u0026amp; !visit(root-\u0026gt;right, last)) { return false; } return true; } }; ","date":"2020-04-01T17:20:18+08:00","permalink":"https://www.orztu.com/leetcode/098-validate-binary-search-tree/","title":"LeetCode 98. Validate Binary Search Tree"},{"content":"Description Interleaving String\nGiven s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.\nExample 1:\nInput: s1 = \u0026quot;aabcc\u0026quot;, s2 = \u0026quot;dbbca\u0026quot;, s3 = \u0026quot;aadbbcbcac\u0026quot;\nOutput: true\nExample 2:\nInput: s1 = \u0026quot;aabcc\u0026quot;, s2 = \u0026quot;dbbca\u0026quot;, s3 = \u0026quot;aadbbbaccc\u0026quot;\nOutput: false\nSolution 题目：\n判断s3是否由s1、s2相互交错而成。\n解：\n判断由s1、s2组成的地图，是否存在路径s3；\nExample1如下图，有多个解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Example1: s3: aadbbcbcac a a b c c (s1) a_a d d b b b b c c_b_c a a_c (s2) a a b c c (s1) a_a d d_b b b_c b b c c a a_c (s2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public: bool isInterleave(string s1, string s2, string s3) { auto width = s1.length() + 1; auto height = s2.length() + 1; if (width + height - 2 != s3.length()) { return false; } if (width == 1 || height == 1) { return (s1.compare(s3) == 0) || (s2.compare(s3) == 0); } std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt; dp; dp.resize(width); for (auto \u0026amp;v : dp) { v.resize(height); } // 初始化第一个位置，然后在循环中判断是否可能往右边/下边走。 dp[0][0] = true; for (int i = 0; i \u0026lt; width; ++i) { for (int j = i == 0 ? 1: 0; j \u0026lt; height; ++j) { char c = s3.at(j + i - 1); // 尝试吃掉s1的字符，则只能由左边走过来 // 如果是上方格子为true,表示当前字符已经使用，不能再次使用 if (i \u0026gt; 0 \u0026amp;\u0026amp; s1.at(i - 1) == c \u0026amp;\u0026amp; dp[i-1][j]) { dp[i][j] = true; } // 尝试吃掉s2的字符，则只能由上边走过来 if (j \u0026gt; 0 \u0026amp;\u0026amp; s2.at(j - 1) == c \u0026amp;\u0026amp; dp[i][j-1]) { dp[i][j] = true; } } } return dp[width-1][height-1]; } }; ","date":"2020-03-31T09:02:58+08:00","permalink":"https://www.orztu.com/leetcode/097-interleaving-string/","title":"LeetCode 97. Interleaving String"},{"content":"Description Unique Binary Search Trees\nGiven n, how many structurally unique BST\u0026rsquo;s (binary search trees) that store values 1 \u0026hellip; n?\nExample:\nInput: 3\nOutput: 5\nExplanation:\nGiven n = 3, there are a total of 5 unique BST\u0026rsquo;s:\n1 2 3 4 5 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 Solution 以n = 3为例，有数字1、2、3；设解为F(3)=f(1~3)；\n对F(3)分解：\n如果以1为root结点，则右边2~3有F(2)=f(2~3)个解 如果以2为root，则左边有F(1)=f(1~1)、右边有F(1)=f(3~3)；总F(1)*F(1) 如果以3为root，则左边有F(2)=f(1~2) 对于1和3两种情形，左边/右边有0个数，我们设为F(0)=1。\n最终：F(3) = F(0)*F(2) + F(1)*F(1) + F(2)*F(0)个解。\n所以可推导出DP公式：\n$$ F(n) = \\sum_{i=0}^{n}F(i) * F(n-i-1) ; F(0) = 1; $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int numTrees(int n) { int *dp = new int[n+1]{1, 1}; // {F(0), F(1)} for (int i = 2; i \u0026lt;= n; ++i) { dp[i] = 0; for (int k = 0; k \u0026lt; i; ++k) { dp[i] += (dp[k] * dp[i - k - 1]); } } int r = dp[n]; delete []dp; return r; } }; ","date":"2020-03-30T11:32:28+08:00","permalink":"https://www.orztu.com/leetcode/096-unique-binary-search-trees/","title":"LeetCode 96. Unique Binary Search Trees"},{"content":"Description Binary Tree Inorder Traversal\nGiven a binary tree, return the inorder traversal of its nodes\u0026rsquo; values.\nExample:\n1 2 3 4 5 6 7 8 Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively?\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; r; inorderVisit(r, root); return r; } private: void inorderVisit(vector\u0026lt;int\u0026gt; \u0026amp;r, TreeNode *node) { std::stack\u0026lt;TreeNode *\u0026gt; s; auto *cur = node; while(cur || !s.empty()) { while(cur) { s.push(cur); cur = cur-\u0026gt;left; } cur = s.top(); s.pop(); r.push_back(cur-\u0026gt;val); cur = cur-\u0026gt;right; } } /* 递归 void inorderVisit(vector\u0026lt;int\u0026gt; \u0026amp;r, TreeNode *node) { if (!node) { return; } if (node-\u0026gt;left) { inorderVisit(r, node-\u0026gt;left); } r.push_back(node-\u0026gt;val); if (node-\u0026gt;right) { inorderVisit(r, node-\u0026gt;right); } } */ }; ","date":"2020-03-26T11:18:43+08:00","permalink":"https://www.orztu.com/leetcode/094-binary-tree-inorder-traversal/","title":"LeetCode 94. Binary Tree Inorder Traversal"},{"content":"Description Restore IP Addresses\nGiven a string containing only digits, restore it by returning all possible valid IP address combinations.\nExample:\n1 2 Input: \u0026#34;25525511135\u0026#34; Output: [\u0026#34;255.255.11.135\u0026#34;, \u0026#34;255.255.111.35\u0026#34;] Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public: Solution() : _empty(\u0026#34;\u0026#34;), _dot(\u0026#34;.\u0026#34;) { } vector\u0026lt;string\u0026gt; restoreIpAddresses(string s) { vector\u0026lt;string\u0026gt; result; solve(result, \u0026#34;\u0026#34;, 0, s); return result; } void solve(vector\u0026lt;string\u0026gt; \u0026amp;result, string ip, int n, string s) { size_t len = s.length(); if (n == 4 ) { if (len == 0) { result.push_back(ip); } return; } string \u0026amp;mid = n \u0026gt; 0 ? _dot : _empty; int cur = 0; for (size_t i = 0; i \u0026lt; len; i++) { cur = cur*10 + static_cast\u0026lt;int\u0026gt;(s.at(i) - \u0026#39;0\u0026#39;); if (cur \u0026gt; 255) { return; } solve(result, ip + mid + s.substr(0, i+1), n + 1, s.substr(i+1)); if (cur == 0) { return; } } } private: string _empty; string _dot; }; ","date":"2019-11-25T15:23:55+08:00","permalink":"https://www.orztu.com/leetcode/093-restore-ip-addresses/","title":"LeetCode 93. Restore IP Addresses"},{"content":" \u0026raquo;\u0026gt;视频地址\u0026laquo;\u0026lt;\n首先我们要在前两个门集满第一管氮气。\n1号门前向右轻打方向调整车头，然后向左拖漂。\n右漂经过2号门然后向左拉正车头后使用第一个氮气。\n立即向右拖漂经过3号门。\n氮气满之后马上拉正车头。\n继续使用氮气，然后拖漂经过4号门，同样气满之后回正。\n趁氮气未结束，再次拖漂经过5号门，然后马上使用氮气。\n5号门相对前面两个门不用漂那么大。\n过了5号门氮气满了断位拉头，然后接左漂继续集气并过6号门。\n7号门前这个小坎需要小漂一下，不然落地容易弹起。\n落地走一点点之后，向左轻漂，不要太大。\n因为已经有两个氮气了，漂满了这一管就浪费了。\n过这个坎向右轻漂，然后落地马上使用氮气。\n然后把刚才没满的氮气漂满，这样又有两个氮气了。\n紧接着再次把氮气漂到快满，以便下坡起跳之后集气。\n使用氮气加速下坡，起跳前向左轻漂，不要用力。\n落地之后氮气满了马上使用氮气纠正车头，避免撞墙；\n如果前面失误，这个时候没有氮气，可以再次向左漂避免撞墙。\n这个坎前向右漂移过弯，同样满了就用氮气回正；\n如果没有氮气可用，就向左拉车头集气，然后使用氮气。\n下一个弯车速起来就向左拖漂过弯，并集满一管气。\n出弯后使用氮气，调整位置，准备从外道插入下一个弯。\n这个弯向右打死，出弯使用氮气或者断位拉头。-\n出弯之后等速度起来拖漂过最后一个弯。\n最后一下起跳前向左轻漂。\n剩余的直线就交给氮气了。\n\u0026raquo;\u0026gt;视频地址\u0026laquo;\u0026lt;\n$ N_{2}O $ 本是笑气，但在跑跑里面被大家称为“氮气”\n","date":"2019-07-11T17:52:17+08:00","permalink":"https://www.orztu.com/post/popkart-l1-4/","title":"跑跑卡丁车手游 L1 驾照“下坡漂移”教程"},{"content":"首先，并非专业视频处理人员；以下命令都是我从网上搜索后修改以为己所用。\n图片转视频 1 2 3 4 5 # gif 转视频（DURATION：时长，gif会循环播放） ffmpeg -ignore_loop 0 -t DURATION -f gif -i \u0026#34;INPUT.gif\u0026#34; -vcodec libx264 -crf 5 \u0026#34;OUTPUT.mp4\u0026#34; # png、jpg 转视频 ffmpeg -loop 1 -framerate 30 -f image2 -t DURATION -i \u0026#34;INPUT.jpg\u0026#34; -vcodec libx264 -crf 5 \u0026#34;OUTPUT.mp4\u0026#34; 给视频添加音轨 1 ffmpeg -y -i \u0026#34;INPUT.mp4\u0026#34; -f lavfi -i anullsrc=channel_layout=stereo:sample_rate=44100 -shortest -c copy -c:a aac -bsf:v h264_mp4toannexb \u0026#34;OUTPUT.mp4\u0026#34; 修改视频分辨率 使用以下命令可以将视频分辨率修改为1280x768，不同比例的视频会填充黑边\n1 ffmpeg -i \u0026#34;INPUT.mp4\u0026#34; -vf \u0026#34;scale=1280:768:force_original_aspect_ratio=decrease,pad=1280:768:(ow-iw)/2:(oh-ih)/2\u0026#34; OUTPUT.mp4 合并视频 如果视频都是相同格式，可以将视频用一下格式列举在一个文件中（也可以用来合并 mp3 文件）：\n1 2 3 4 # concat.txt file input1.mp4 file input2.mp4 file input3.mp4 然后使用以下命令拼接：\n1 ffmpeg -safe 0 -f concat -i \u0026#34;concat.txt\u0026#34; -c copy \u0026#34;OUTPUT.mp4\u0026#34; 如果是不同格式的视频合并：\n1 2 3 4 ffmpeg -i INPUT1.mp4 -c copy -bsf:v h264_mp4toannexb -f mpegts input1.ts ffmpeg -i INPUT2.mp4 -c copy -bsf:v h264_mp4toannexb -f mpegts input2.ts ffmpeg -i INPUT3.mp4 -c copy -bsf:v h264_mp4toannexb -f mpegts input3.ts ffmpeg -y -i \u0026#34;concat:input1.ts|input2.ts|input3.ts\u0026#34; -c copy -bsf:a aac_adtstoasc -movflags +faststart OUTPUT.mp4 截取视频段 以下命令将从视频 1 分钟的位置开始，截取 15 秒。不要用-c copy，不然视频会缺少关键帧。\n1 ffmpeg -ss 00:01:00 -accurate_seek -i INPUT.mp4 -t 15 OUTPUT.mp4 加速视频和音频 以下命令将 mp3 加速为1.1倍\n1 ffmpeg -i INPUT.mp3 -filter_complex \u0026#34;[0:a]atempo=1.1[a]\u0026#34; -map \u0026#34;[a]\u0026#34; \u0026#34;OUTPUT.mp3\u0026#34; 以下命令将视频和音频同时加速为1.3倍（1/1.3 = 0.769230769231）\n1 ffmpeg -i INPUT.mp4 -filter_complex \u0026#34;[0:v]setpts=0.769230769231*PTS[v];[0:a]atempo=1.300000[a]\u0026#34; -map \u0026#34;[v]\u0026#34; -map \u0026#34;[a]\u0026#34; OUTPUT.mp4 添加srt字幕 1 ffmpeg -i INPUT.mp4 -i INPUT.srt -c:s mov_text -c:v copy -c:a copy OUTPUT.mp4 ","date":"2019-06-15T14:45:05+08:00","permalink":"https://www.orztu.com/post/ffmpeg-commands/","title":"ffmpeg 命令行"},{"content":"Description Reverse Linked List II\nReverse a linked list from position m to n. Do it in one-pass.\nNote: 1 ≤ m ≤ n ≤ length of list.\nExample:\n1 2 Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, m = 2, n = 4 Output: 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5-\u0026gt;NULL 遍历一次将链表的第m至n个结点翻转。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func reverseBetween(head *ListNode, m int, n int) *ListNode { slow := \u0026amp;ListNode{ Next: head, } fast := slow.Next head = slow for i := 1; i \u0026lt; m; i++ { fast = fast.Next slow = slow.Next } // start指向第一个需要翻转的位置 pre, start := slow, fast // 进行翻转 // 1. 将fast.Next倒转，指向slow // 2. 同时fast和slow前进一步 for i := m; i \u0026lt;= n; i++ { fast.Next, fast, slow = slow, fast.Next, fast } pre.Next = slow start.Next = fast return head.Next } ","date":"2019-03-20T14:59:04+08:00","permalink":"https://www.orztu.com/leetcode/092-reverse-linked-list-ii/","title":"LeetCode 92. Reverse Linked List II"},{"content":"Description Decode Ways\nA message containing letters from A-Z is being encoded to numbers using the following mapping:\n1 2 3 4 \u0026#39;A\u0026#39; -\u0026gt; 1 \u0026#39;B\u0026#39; -\u0026gt; 2 ... \u0026#39;Z\u0026#39; -\u0026gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it.\nExample 1:\n1 2 3 Input: \u0026#34;12\u0026#34; Output: 2 Explanation: It could be decoded as \u0026#34;AB\u0026#34; (1 2) or \u0026#34;L\u0026#34; (12). Example 2:\n1 2 3 Input: \u0026#34;226\u0026#34; Output: 3 Explanation: It could be decoded as \u0026#34;BZ\u0026#34; (2 26), \u0026#34;VF\u0026#34; (22 6), or \u0026#34;BBF\u0026#34; (2 2 6). Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func numDecodings(s string) int { if len(s) == 0 || s[0] == \u0026#39;0\u0026#39; { return 0 } dp := make([]int, len(s)+1) dp[0] = 1 dp[1] = 1 for i := 1; i \u0026lt; len(s); i++ { if s[i] == \u0026#39;0\u0026#39; { if s[i-1] == \u0026#39;1\u0026#39; || s[i-1] == \u0026#39;2\u0026#39; { // if this number is \u0026#39;0\u0026#39; // the previous number must be \u0026#39;1\u0026#39; or \u0026#39;2\u0026#39; // and the previous solution(dp[i]) should return to dp[i-1] // dp[i] = dp[i-1] dp[i+1] = dp[i-1] } else { return 0 } } else if s[i-1] == \u0026#39;1\u0026#39; || (s[i-1] == \u0026#39;2\u0026#39; \u0026amp;\u0026amp; s[i]-\u0026#39;0\u0026#39; \u0026lt;= 6) { // if this number is not \u0026#39;0\u0026#39; // like 226, when i is 2, number is 6 // it can be splitted as \u0026#34;2|26\u0026#34; or \u0026#34;22|6\u0026#34; // so it can be from [2] and [22] dp[i+1] = dp[i] + dp[i-1] } else { // else there is only one way dp[i+1] = dp[i] } } return dp[len(s)] } ","date":"2019-01-30T17:19:21+08:00","permalink":"https://www.orztu.com/leetcode/091-decode-ways/","title":"LeetCode 91. Decode Ways"},{"content":"Description Subsets II\nGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\nNote: The solution set must not contain duplicate subsets.\nExample:\n1 2 3 4 5 6 7 8 9 10 Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 假设没有重复元素，每个元素有出现、不出现两种情况。\n当有重复元素后，假设重复元素：[2, 2, 2]，对于元素2有不出现、出现一次[2]、出现两次[2, 2]、出现三次[2, 2, 2]\n四种情况。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func subsetsWithDup(nums []int) [][]int { sort.Ints(nums) result := [][]int{[]int{}} for i := 0; i \u0026lt; len(nums); { curLen := len(result) // cout of this number count := 1 for j := i + 1; j \u0026lt; len(nums) \u0026amp;\u0026amp; nums[j] == nums[i]; j++ { count++ } for idx := 0; idx \u0026lt; curLen; idx++ { for k := 1; k \u0026lt;= count; k++ { r := make([]int, len(result[idx])) copy(r, result[idx]) // if the numver is visible // and if it\u0026#39;s duplicate, eg. [2, 2, 2] // we can put in [2]、 [2, 2] or [2, 2, 2] for n := 0; n \u0026lt; k; n++ { r = append(r, nums[i]) } result = append(result, r) } } i += count } return result } Similar Problem 78. Subsets ","date":"2019-01-30T15:59:41+08:00","permalink":"https://www.orztu.com/leetcode/090-subsets-ii/","title":"LeetCode 90. Subsets II"},{"content":"Description Merge Sorted Array\nGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.\nNote:\nThe number of elements initialized in nums1 and nums2 are m and n respectively.\nYou may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.\nExample:\n1 2 3 4 5 Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] 将nums1、nums2两个有序数组合并到nums1一个中，nums1已分配足够空间存放元素。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func merge(nums1 []int, m int, nums2 []int, n int) { // from back to front for i := m + n - 1; i \u0026gt;= 0; i-- { n1, n2 := math.MinInt64, math.MinInt64 if m \u0026gt; 0 { n1 = nums1[m-1] } if n \u0026gt; 0 { n2 = nums2[n-1] } // move the bigger one to the tail // then dec the count if n1 \u0026gt;= n2 { nums1[i] = n1 m-- } else { nums1[i] = n2 n-- } } } Similar Problem 21. Merge Two Sorted Lists ","date":"2019-01-03T11:46:11+08:00","permalink":"https://www.orztu.com/leetcode/088-merge-sorted-array/","title":"LeetCode 88. Merge Sorted Array"},{"content":"Description Scramble String\nGiven a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.\nBelow is one possible representation of s1 = \u0026quot;great\u0026quot;:\n1 2 3 4 5 6 7 great / \\ gr eat / \\ / \\ g r e at / \\ a t To scramble the string, we may choose any non-leaf node and swap its two children.\nFor example, if we choose the node \u0026quot;gr\u0026quot; and swap its two children, it produces a scrambled string \u0026quot;rgeat\u0026quot;.\n1 2 3 4 5 6 7 rgeat / \\ rg eat / \\ / \\ r g e at / \\ a t We say that \u0026quot;rgeat\u0026quot; is a scrambled string of \u0026quot;great\u0026quot;.\nSimilarly, if we continue to swap the children of nodes \u0026quot;eat\u0026quot; and \u0026quot;at\u0026quot;, it produces a scrambled string \u0026quot;rgtae\u0026quot;.\n1 2 3 4 5 6 7 rgtae / \\ rg tae / \\ / \\ r g ta e / \\ t a We say that \u0026quot;rgtae\u0026quot; is a scrambled string of \u0026quot;great\u0026quot;.\nGiven two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.\nExample 1:\n1 2 Input: s1 = \u0026#34;great\u0026#34;, s2 = \u0026#34;rgeat\u0026#34; Output: true Example 2:\n1 2 Input: s1 = \u0026#34;abcde\u0026#34;, s2 = \u0026#34;caebd\u0026#34; Output: false Solution You may considering the string is not always split at the middle.\nThe tree could be like this:\n1 2 3 4 5 6 great / \\ g reat / \\ r eat ... Divide And Conquer (Top to Down) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func isScramble(s1 string, s2 string) bool { if s1 == s2 { return true } length := len(s1) // couting letters var count [26]int for i := 0; i \u0026lt; length; i++ { count[s1[i]-\u0026#39;a\u0026#39;]++ count[s2[i]-\u0026#39;a\u0026#39;]-- } // Does letters same? for i := 0; i \u0026lt; 26; i++ { if count[i] != 0 { return false } } for k := 1; k \u0026lt; length; k++ { if isScramble(s1[k:], s2[k:]) \u0026amp;\u0026amp; isScramble(s1[:k], s2[:k]) { return true } // exchange substrings if isScramble(s1[k:], s2[:length-k]) \u0026amp;\u0026amp; isScramble(s1[:k], s2[length-k:]) { return true } } return false } Dynamic Programming (Bottom to Up) Definition dp[l][i][j]:\ns1[i] start from 'i' s2[j] start from 'j' 'l' is the length of substring, the length in recursive solution. Initialization dp[1][i][j] = (s1[i] == s2[j] ? true : false).\n1 2 3 4 5 6 dp[l][i][j] = // isScramble(s1[k:], s2[k:]) \u0026amp;\u0026amp; isScramble(s1[:k], s2[:k]) (dp[k][i][j] \u0026amp;\u0026amp; dp[l-k][i+k][j+k]) || // isScramble(s1[k:], s2[:length-k]) \u0026amp;\u0026amp; isScramble(s1[:k], s2[length-k:]) (dp[k][i][j+l-k] \u0026amp;\u0026amp; dp[l-k][i+k][j]) k means split the l to two parts, so 0 \u0026lt;= k \u0026lt;= l;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 func isScramble(s1 string, s2 string) bool { if len(s1) != len(s2) { return false } length := len(s1) dp := make([][][]bool, length+1) for i := 0; i \u0026lt;= length; i++ { dp[i] = make([][]bool, length) for j := 0; j \u0026lt; length; j++ { dp[i][j] = make([]bool, length) } } for i := 0; i \u0026lt; length; i++ { for j := 0; j \u0026lt; length; j++ { dp[1][i][j] = (s1[i] == s2[j]) } } for l := 2; l \u0026lt;= length; l++ { for i := 0; i \u0026lt; length-l+1; i++ { for j := 0; j \u0026lt; length-l+1; j++ { if dp[l][i][j] { continue } for k := 1; k \u0026lt; l \u0026amp;\u0026amp; (!dp[l][i][j]); k++ { dp[l][i][j] = (dp[k][i][j] \u0026amp;\u0026amp; dp[l-k][i+k][j+k]) || (dp[k][i][j+l-k] \u0026amp;\u0026amp; dp[l-k][i+k][j]) } } } } return dp[length][0][0] } ","date":"2019-01-03T09:14:13+08:00","permalink":"https://www.orztu.com/leetcode/087-scramble-string/","title":"LeetCode 87. Scramble String"},{"content":"闪退点 Version: Cocos2dx-Lua 3.16\n在某个页面修改后，出现闪退。查看修改记录没有特别的地方，均为修改图片或者条件判断。\n启动 XCode 发现闪退位置出现在void Node::onEnterTransitionDidFinish()中，\n在其调用子节点的child-\u0026gt;onEnterTransitionDidFinish()时，child指针无效。\n1352 1353 1354 ... for( const auto \u0026amp;child: \\_children) child-\u0026gt;onEnterTransitionDidFinish(); 此时的调用栈：\n1 2 3 4 0: void Node::onEnterTransitionDidFinish() -\u0026gt; child-\u0026gt;onEnterTransitionDidFinish(); 1: void Director::setNextScene() -\u0026gt; _runningScene-\u0026gt;onEnterTransitionDidFinish(); 2: void Director::drawScene() -\u0026gt; setNextScene(); ... 对应 Lua 代码流程：\n1 2 3 4 display.runScene(HomeScene) HomeScene:ctor() { self:addChild(HomeLayer) } 怀疑 因为是在调用Scene::onEnterTransitionDidFinish()时指针无效，所以猜测是遍历过程中字节点被删除。\n查看相关代码：\n1 2 3 4 HomeScene: 没有 onEnterTransitionDidFinish() HomeLayer: 有 onEnterTransitionDidFinish()， 但在 onEnterTransitionDidFinish 中没有删除 HomeScene 上的结点。 而是往 Scene 上新增结点 addChild(GuideLayer) 因为游戏逻辑是只创建一个GuideLayer，重复创建时会删除上次创建的页面。又怀疑是否创建了两次GuideLayer。\n通过屏蔽代码发现不添加GuideLayer就不会闪退，但是GuideLayer的确只创建了一次，不存在删除问题。\n真相 再次分析流程\n1 2 3 4 5 6 HomeScene:onEnterTransitionDidFinish(): HomeLayer:onEnterTransitionDidFinish( addChild(GuideLayer) // 添加到HomeScene上 ) HomeScene:onEnterTransitionDidFinish() 闪退 总归问题是出现在HomeScene的_children容器上，那么既然不是删除，增加结点会导致容器出问题吗？\n查找代码得到_children类型为CCVector，而CCVector通过std::vector实现。\n所以出现了常见的**问题：在容器迭代过程中删除或插入**。\n在新增结点往std::vector插入的时候，恰好超过容量大小，导致扩容。而std::vector是分配的连续内存，\n所以扩容时候会重新分配内存，导致遍历的时候出现child指针无效。\n1 2 3 4 5 6 7 8 scene::onEnterTransitionDidFinish() { for (child: scene-\u0026gt;children) { // onEnterTransitionDidFinish里面往scene中addChild // 导致children容器扩容，for循环的child指针失效 // 然后下一轮循环再到这里，child(无效指针)-\u0026gt;onEnterTransitionDidFinish()就会闪退 child-\u0026gt;onEnterTransitionDidFinish(); } } else 那么是不是就不能在onEnterTransitionDidFinish中添加结点呢？\n在这个项目，许多页面都在onEnterTransitionDidFinish往HomeScene添加GuideLayer；或者在当前页面添加结点，为啥运行了这么久都没发现问题？\n查看代码可以得到，C++ 中onEnterTransitionDidFinish是在遍历完子节点后，\n再发送消息调用Lua中的onEnterTransitionDidFinish的：\n1 2 3 4 5 for( const auto \u0026amp;child: _children) child-\u0026gt;onEnterTransitionDidFinish(); ... // 调用当前结点 Lua 的 onEnterTransitionDidFinish ScriptEngineManager::sendNodeEventToLua(this, kNodeOnEnterTransitionDidFinish); 而项目中的页面管理是这样做的：进入游戏创建HomeScene，之后其他页面跳转均在HomeScene上删除和添加，几乎不会创建新 Scene 。\n所以后面不会再遇到HomeScene::onEnterTransitionDidFinish遍历时添加子结点的情况；而直接往当前页面添加结点，也是在当前页面的_children遍历完后再添加的(Lua 中添加)。\n","date":"2018-12-22T09:22:48+08:00","permalink":"https://www.orztu.com/post/little-problem-while-using-cocos2dx-lua/","title":"记一次 Cocos2dx-Lua 闪退"},{"content":"Description Partition List\nGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\nExample:\n1 2 Input: head = 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5-\u0026gt;2, x = 3 Output: 1-\u0026gt;2-\u0026gt;2-\u0026gt;4-\u0026gt;3-\u0026gt;5 Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func partition(head *ListNode, x int) *ListNode { // use a new linked list to save \u0026#39;bigger nodes\u0026#39; bigger := \u0026amp;ListNode{} biggerTail := bigger // this linked list to save \u0026#39;smaller nodes\u0026#39; slow := \u0026amp;ListNode{ Next: head, } head = slow fast := slow.Next for fast != nil { if fast.Val \u0026lt; x { // slow go to fast(go to slow.next) slow = fast } else { // skip fast, go fast.Next(got slow.next.next) slow.Next = fast.Next // break after fast fast.Next = nil // append fast to bigger linked list biggerTail.Next = fast biggerTail = biggerTail.Next } fast = slow.Next } // concat the two linked lists slow.Next = bigger.Next return head.Next } ","date":"2018-12-18T10:07:22+08:00","permalink":"https://www.orztu.com/leetcode/086-partition-list/","title":"LeetCode 86. Partition List"},{"content":"在日志信息中，有时需要获取当前函数的调用信息，比如打印调用栈：\n调用栈 debug.Stack() []byte debug.Stack()函数可以获取当前 goroutine 的调用栈信息，需要import \u0026quot;runtime/debug\u0026quot;。\n8 9 10 11 12 13 14 15 16 17 18 19 20 func foo() { fmt.Println(\u0026#34;--- BEGIN ---\u0026#34;) fmt.Println(string(debug.Stack())) fmt.Println(\u0026#34;--- END ---\u0026#34;) } func boom() { foo() } func main() { boom() } 可以获得类似输出结果：\n1 2 3 4 5 6 7 8 9 10 11 12 --- BEGIN --- goroutine 1 [running]: runtime/debug.Stack(0xc00006ef58, 0x1, 0x1) /usr/local/Cellar/go/1.11.2/libexec/src/runtime/debug/stack.go:24 +0xa7 main.foo() xxx/trace.go:10 +0x66 main.boom() xxx/trace.go:15 +0x20 main.main() xxx/trace.go:19 +0x20 --- END --- runtime.Stack(buf []byte, all bool) int debug.Stack()函数源码在runtime/debug/stack.go中：\n1 2 3 4 5 6 7 8 9 10 func Stack() []byte { buf := make([]byte, 1024) for { n := runtime.Stack(buf, false) if n \u0026lt; len(buf) { return buf[:n] } buf = make([]byte, 2*len(buf)) } } 可以看到它是通过调用runtime.Stack获取的调用栈信息，\n其中第二个参数all表示是否获取所有 goroutine 的调用栈。\n可以将第二个参数改为true然后创建多个 goroutine 查看输出效果。\n更可控的调用信息 上面两个函数虽然可以获取调用栈，但是直接将所有调用信息返回，控制参数较少。\n下面几个函数可以实现获取单层的调用信息。\nruntime.Caller(skip int) (pc uintptr, file string, line int, ok bool) runtime.Caller函数可以获取调用者的信息\n参数skip：表示跳过的层级，相当于往上获取第几层的调用者。0 表示当前函数，1 表示上一层函数，依次往上。\n返回值\npc：program counter（不知道该怎么翻译，程序计数器？），可以大概理解为函数编号，可以通过runtime.FuncForPC解析 file：文件名 line：行号 8 9 10 11 12 13 func foo() { pc, file, line, ok := runtime.Caller(1) if ok { fmt.Println(runtime.FuncForPC(pc).Name(), file, line) } } 可以得到这样一条输出：\n1 main.boom xxx/trace.go 16 runtime.Callers(skip int, pc []uintptr) int runtime.Callers一次可以获取调用栈中多个program counter。\n但是第一个参数skip与上面的runtime.Caller稍有不同，如果传0会获取到Callers函数本身的信息。\n传1时才与上面的Caller函数对应。\n8 9 10 11 12 13 14 15 16 func foo() { pc := make([]uintptr, 10) n := runtime.Callers(1, pc) for i := 0; i \u0026lt; n; i++ { f := runtime.FuncForPC(pc[i]) file, line := f.FileLine(pc[i]) fmt.Printf(\u0026#34;%s %d %s\\n\u0026#34;, file, line, f.Name()) } } 输出：\n1 2 3 4 5 xxx/trace.go 10 main.foo xxx/trace.go 20 main.boom xxx/trace.go 24 main.main /usr/local/Cellar/go/1.11.2/libexec/src/runtime/proc.go 210 runtime.main /usr/local/Cellar/go/1.11.2/libexec/src/runtime/asm_amd64.s 1334 runtime.goexit runtime.CallersFrames(callers []uintptr) *runtime.Frames runtime.CallersFrames可以一次解析多个pc\n8 9 10 11 12 13 14 15 16 17 18 19 func foo() { pc := make([]uintptr, 10) n := runtime.Callers(1, pc) frames := runtime.CallersFrames(pc[:n]) var frame runtime.Frame more := n \u0026gt; 0 for more { frame, more = frames.Next() fmt.Printf(\u0026#34;%s %d %s\\n\u0026#34;, frame.File, frame.Line, frame.Function) } } func runtime.FuncForPC(pc uintptr) *runtime.Func 前面使用了runtime.FuncForPC来解析pc，获得函数信息。\n它返回的*runtime.Func主要有三个方法：\nEntry() uintptr: 返回函数入口地址（函数注释Entry address of the function） Name() string: 返回函数名 FileLine(pc uintptr) (file string, line int): 返回文件名和行号 ","date":"2018-12-12T15:38:49+08:00","permalink":"https://www.orztu.com/post/golang-trace/","title":"在 Golang 中打印调用栈信息"},{"content":"Description Maximal Rectangle\nGiven a 2D binary matrix filled with 0\u0026rsquo;s and 1\u0026rsquo;s, find the largest rectangle containing only 1\u0026rsquo;s and return its area.\nExample:\n1 2 3 4 5 6 7 8 Input: [ [\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;] ] Output: 6 在给出的矩阵中，1表示元素，0表示空，找出最大矩形的面积。\nSolution 本题可以利用《84. Largest Rectangle in Histogram》\n的代码。\n下面来看看如何转换成 84 题的直方图求解问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 矩阵： [10100] [10111] [11111] [10010] 第一行，将 0 及其上方元素去掉： [1 1 ] 第二行，将 0 及其上方元素去掉： [1 1 ] [1 111] 第三行，将 0 及其上方元素去掉： [1 1 ] [1 111] [11111] 第四行，将 0 及其上方元素去掉： [1 ] [1 1 ] [1 1 ] [1 1 ] 通过四次转换，其实得到四个直方图： [10100]、[20211]、[31322]、[4030] 至此已将矩阵问题转换成了之前的直方图问题。使用相应代码求解即可。 下面largestRectangleArea的代码点击这里查看。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func maximalRectangle(matrix [][]byte) int { h := len(matrix) if h == 0 { return h } w := len(matrix[0]) max := 0 heights := make([]int, w) for j := 0; j \u0026lt; h; j++ { for i := 0; i \u0026lt; w; i++ { if matrix[j][i] == \u0026#39;1\u0026#39; { heights[i]++ } else { heights[i] = 0 } } max = maxInt(max, largestRectangleArea(heights)) } return max } Similar Problem 84. Largest Rectangle in Histogram ","date":"2018-12-12T11:42:17+08:00","permalink":"https://www.orztu.com/leetcode/085-maximal-rectangle/","title":"LeetCode 85. Maximal Rectangle"},{"content":"Description Largest Rectangle in Histogram\nGiven n non-negative integers representing the histogram\u0026rsquo;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\nAbove is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].\nThe largest rectangle is shown in the shaded area, which has area = 10 unit.\n给出一个直方图，求最大矩形面积。\nSolution 首先假设直方图是升序的，比如：1, 3, 5, 6, 7\n那么需要比较的面积有：1*5，3 * 4，5*3，6*2，7*1。\n计算公式为：$ S(i) = height[i] * (length-i) $\n所以最大面积：$ \\max_{i=0}^n{S(i)} $\n那遇到无序的数组怎么办呢？\n根据提示可以是用栈，目的是用于构造升序数组：\n假设当前高度为h：\n如果升序则直接入栈 遇到降序，将栈中所有比h高的都利用公式计算出面积，然后降低它们的高度至h，使数组重新有序 例如数组1, 3, 4, 2, 3：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ^ | 0 | 00 0 | 0000 | 00000 .-------\u0026gt; 首先：1，3，4 都是升序，依次入栈（下标入栈）： ^ | 0 stack: | 00 [2] | 00 [1] | 000 [0] .-------\u0026gt; 遇到：2，不符合升序，计算前面 3 和 4 的面积分别为：S(1)=3*2，S(2)=4*1 然后降低高度至 2 ^ | stack: 将 4 的下标出栈，保留 3 的下标（因为 3 所在位置是新高度的起点） | | 000 [1] | 0000 [0] .-------\u0026gt; 遇到：3，符合升序，直接入栈 ^ | stack: | 0 [4] | 0000 [1] | 00000 [0] .-------\u0026gt; 最后仍需要计算的面积有：S(0)=1*5，S(1)=2*4，S(4)=3*1 所以最大面积为 8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 func maxInt(a, b int) int { if a \u0026gt; b { return a } return b } func largestRectangleArea(heights []int) int { stack := make([]int, 0) lenStack := len(stack) max := 0 // 追加一个 -1，用于最后清空栈 heights = append(heights, -1) for i := 0; i \u0026lt; len(heights); i++ { h := heights[i] if lenStack \u0026gt; 0 \u0026amp;\u0026amp; h \u0026lt; heights[stack[lenStack-1]] { // 如果前面更高，将更高的都出栈 // 同时计算面积，然后降低它们的高度（形成新的“有序”） for { idx := stack[lenStack-1] // 计算面积 max = maxInt(max, heights[idx]*(i-idx)) // 降低高度 heights[idx] = h lenStack-- // 假出栈 if lenStack == 0 || h \u0026gt; heights[stack[lenStack-1]] { // 最后一个，保留在栈中作为新高度的起点 lenStack++ break } stack = stack[:lenStack] } } else /* 这个判断可有可无 if lenStack == 0 || h \u0026gt; heights[stack[lenStack-1]] */ { // 将当前索引入栈 stack = append(stack, i) lenStack++ } } return max } Similar Problem 85. Maximal Rectangle ","date":"2018-12-11T10:10:38+08:00","permalink":"https://www.orztu.com/leetcode/084-largest-rectangle-in-histogram/","title":"LeetCode 84. Largest Rectangle in Histogram"},{"content":"Description Remove Duplicates from Sorted List II\nGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.\nExample 1:\n1 2 Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5 Output: 1-\u0026gt;2-\u0026gt;5 Example 2:\n1 2 Input: 1-\u0026gt;1-\u0026gt;1-\u0026gt;2-\u0026gt;3 Output: 2-\u0026gt;3 删除链表中有重复的结点\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if (head == NULL) { return NULL; } auto h = ListNode(0); h.next = head; auto *p1 = \u0026amp;h; auto *p2 = p1-\u0026gt;next; auto *cur = p2-\u0026gt;next; while (cur) { if (cur-\u0026gt;val == p2-\u0026gt;val) { // 循环移除重复的结点 do { cur = cur-\u0026gt;next; }while(cur \u0026amp;\u0026amp; cur-\u0026gt;val == p2-\u0026gt;val); p1-\u0026gt;next = cur; // 然后移除p2指向的结点（p1-\u0026gt;next == p2） if (!cur) { break; } } else { p1 = p2; // (p1 = p1-\u0026gt;next) } p2 = cur; cur = cur-\u0026gt;next; } return h.next; } }; ","date":"2018-12-10T15:30:20+08:00","permalink":"https://www.orztu.com/leetcode/082-remove-duplicates-from-sorted-list-ii/","title":"LeetCode 82. Remove Duplicates From Sorted List II"},{"content":"Description Search in Rotated Sorted Array II\nSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).\nYou are given a target value to search. If found in the array return true, otherwise return false.\nExample 1:\n1 2 Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true Example 2:\n1 2 Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow up:\nThis is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why? Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public: bool search(const std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int l = 0; int r = nums.size() - 1; int mid, lnum, mnum, rnum; while (l \u0026lt;= r) { mid = l + (r - l)/2; lnum = nums.at(l); mnum = nums.at(mid); rnum = nums.at(r); // 一次判断三个数 if (mnum == target || lnum == target || rnum == target) { return true; } else if (lnum \u0026lt; mnum) { // lnum \u0026lt; mnum 表示左边有序，那么判断target是否落在左边 if (target \u0026lt; mnum \u0026amp;\u0026amp; target \u0026gt;= lnum) { r = mid - 1; } else { l = mid + 1; } } else if (rnum \u0026gt; mnum) { // rnum \u0026gt; mnum 表示右边有序，那么判断target是否落在右边 if (target \u0026gt; mnum \u0026amp;\u0026amp; target \u0026lt;= rnum) { l = mid + 1; } else { r = mid - 1; } } else { // 收紧区域 r--, l++; } } return false; } }; Similar Problem 33. Search in Rotated Sorted Array ","date":"2018-12-10T14:34:14+08:00","permalink":"https://www.orztu.com/leetcode/081-search-in-rotated-sorted-array-ii/","title":"LeetCode 81. Search in Rotated Sorted Array II"},{"content":"Description Remove Duplicates from Sorted Array II\nGiven a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nExample 1:\n1 2 3 4 5 6 Given nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It doesn\u0026#39;t matter what you leave beyond the returned length. Example 2:\n1 2 3 4 5 6 Given nums = [0,0,1,1,1,1,2,3,3], Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively. It doesn\u0026#39;t matter what values are set beyond the returned length. 在有序数组中删除重复的元素，每个元素允许重复一次（出现两次）。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func removeDuplicates(nums []int) int { length := len(nums) if length \u0026lt;= 2 { return length } readPointer, writePointer := 0, 0 for readPointer \u0026lt; length { // 写入一次 nums[writePointer] = nums[readPointer] writePointer++ readPointer++ if readPointer \u0026gt;= length { break } // 如果存在一个相同的，则再写入一次 // 然后跳过后面重复的数字 if nums[readPointer] == nums[writePointer-1] { nums[writePointer] = nums[readPointer] writePointer++ readPointer++ // 跳过重复的 for readPointer \u0026lt; length \u0026amp;\u0026amp; nums[readPointer] == nums[writePointer-1] { readPointer++ } } } return writePointer } ","date":"2018-12-06T09:33:43+08:00","permalink":"https://www.orztu.com/leetcode/080-remove-duplicates-from-sorted-array-ii/","title":"LeetCode 80. Remove Duplicates from Sorted Array II"},{"content":"Description Word Search\nGiven a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample:\n1 2 3 4 5 6 7 8 9 10 board = [ [\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;E\u0026#39;], [\u0026#39;S\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;S\u0026#39;], [\u0026#39;A\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;E\u0026#39;] ] Given word = \u0026#34;ABCCED\u0026#34;, return true. Given word = \u0026#34;SEE\u0026#34;, return true. Given word = \u0026#34;ABCB\u0026#34;, return false. 在board中查找是否存在相连（相邻）的字符与给定的单词对应。\n很像一个走迷宫的题目，搜索下一步是否与单词的字母匹配，是则走到该位置。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 func exist(board [][]byte, word string) bool { height := len(board) if height == 0 { return false } width := len(board[0]) if width == 0 { return false } w := []byte(word) wLength := len(w) var solve func(x, y, wordIndex int) bool solve = func(x, y, wordIndex int) bool { // 单词搜索完毕 if wordIndex \u0026gt;= wLength { return true } // 边界检查 if x \u0026gt;= width || x \u0026lt; 0 { return false } if y \u0026gt;= height || y \u0026lt; 0 { return false } // 检查当前格是否匹配 if board[y][x] != w[wordIndex] { return false } // 修改当前格，避免重复搜索 tmp := board[y][x] board[y][x] = byte(0) // 搜索下一格 ok := solve(x-1, y, wordIndex+1) || solve(x, y-1, wordIndex+1) || solve(x+1, y, wordIndex+1) || solve(x, y+1, wordIndex+1) // 还原当前格 board[y][x] = tmp return ok } for i := 0; i \u0026lt; height; i++ { for j := 0; j \u0026lt; width; j++ { if solve(j, i, 0) { return true } } } return false } ","date":"2018-12-05T14:29:27+08:00","permalink":"https://www.orztu.com/leetcode/079-word-search/","title":"LeetCode 79. Word Search"},{"content":"Description Subsets\nGiven a set of distinct integers, nums, return all possible subsets (the power set).\nNote: The solution set must not contain duplicate subsets.\nExample:\nInput: nums = [1,2,3]\nOutput:\n[\n[3],\n[1],\n[2],\n[1,2,3],\n[1,3],\n[2,3],\n[1,2],\n[]\n]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 求所有子集（幂集），包含一个空集。 ## Solution ### 回溯（Backtracking） 与上一题[《LeetCode 77. Combinations》](/leetcode/077-combinations/) 的思路相似 可以递归回溯，分别找出`k`从`0-\u0026gt;len(nums)`的所有组合。 ### 位运算（Bit Manipulation） 设长度`l = len(nums)`，设有一个`l`位二进制数`flag`，每一位对应`nums`中的一个数字。 如果这一位为`1`，表示对应数字显示；为`0`表示隐藏。 那么`flag`的所有二进制组合可以对应`nums`的所有子集 很容易得到：$ flag \\in [0, 2^l) $ 比如题目中的例子： nums = [1, 2, 3]\nwhen flag=0 b(000) =\u0026gt; []\nwhen flag=1 b(001) =\u0026gt; [ , , 3]\nwhen flag=2 b(010) =\u0026gt; [ , 2, ]\nwhen flag=3 b(011) =\u0026gt; [ , 2, 3]\nwhen flag=4 b(100) =\u0026gt; [1, , ]\nwhen flag=5 b(101) =\u0026gt; [1, , 3]\nwhen flag=6 b(110) =\u0026gt; [1, 2, ]\nwhen flag=7 b(111) =\u0026gt; [1, 2, 3]\n1 2 3 4 5 6 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func subsets(nums []int) [][]int { l := len(nums) // power: 2^l n := 1 \u0026lt;\u0026lt; uint(l) result := [][]int{} for i := 0; i \u0026lt; n; i++ { // each bit means a number in []nums // if the bit is 1, the number is visible // else the number is invisible flag := i r := []int{} for j := 0; j \u0026lt; l; j++ { // check if this number visible if flag\u0026amp;0x01 \u0026gt; 0 { r = append(r, nums[j]) } // right-shift flag \u0026gt;\u0026gt;= 1 } result = append(result, r) } return result } ## Similar Problem - [90. Subsets II](/leetcode/090-subsets-ii/) ","date":"2018-12-05T11:03:48+08:00","permalink":"https://www.orztu.com/leetcode/078-subsets/","title":"LeetCode 78. Subsets"},{"content":"Description Combinations\nGiven two integers n and k, return all possible combinations of k numbers out of 1 \u0026hellip; n.\nExample:\n1 2 3 4 5 6 7 8 9 10 Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 给出两个整数n和k，输出所有包含k个数字的组合，数字范围1..n。\nSolution 224 ms, faster than 97.50%\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 func combine(n int, k int) [][]int { result := [][]int{} // C(n, k) minK := k if n-k \u0026lt; minK { minK = n - k } p, c := 1, 1 for i := 0; i \u0026lt; minK; i++ { c *= minK - i p *= n - i } c = p / c // 一次性申请内存，+k额外用于递归时存放 memo := make([]int, c*k+k) // 前面k个用于递归时使用，结果从第k+1个开始 start := k var solve func(n, kk int) solve = func(it, kk int) { if kk == k-1 { for it \u0026lt; n { it++ memo[kk] = it r := memo[start : start+k] copy(r, memo) result = append(result, r) start += k } } else { for it \u0026lt; n { it++ memo[kk] = it solve(it, kk+1) } } } solve(0, 0) return result } ","date":"2018-12-03T08:56:03+08:00","permalink":"https://www.orztu.com/leetcode/077-combinations/","title":"LeetCode 77. Combinations"},{"content":"Description Minimum Window Substring\nGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\nExample:\n1 2 Input: S = \u0026#34;ADOBECODEBANC\u0026#34;, T = \u0026#34;ABC\u0026#34; Output: \u0026#34;BANC\u0026#34; Note:\nIf there is no such window in S that covers all characters in T, return the empty string \u0026ldquo;\u0026rdquo;. If there is such window, you are guaranteed that there will always be only one unique minimum window in S. 给出两个字符串S和T，在S中找到一个最短的子串，它包含T中所有的字符。\n需要注意的是的是T中一个字符会出现多次，在子串同样需要多次。\nSolution 设两个指针表示子串的首尾：left，right：\nright向右移动扩展子串，直到子串包含T：\nleft向右移动收缩子串，直到最短满足T，记录子串：\nleft再次右移，这时子串不再满足包含T：\nright从重复第二步骤，找到新的子串：\n再次收缩子串，与之前的子串比较是否更短：\n之前是使用map来做记录，需要26ms，后来第一名使用数组记录更快，可以跑进4ms。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 func minWindow(s string, t string) string { m := make([]int, 128) // 记录有多少个不同的字符 espect := 0 // 每次遇到一个字符就减一 // 在后面遍历的时候加一，遇到等于0表示当前字符恰好满足数量 for _, v := range []byte(t) { if m[v] == 0 { espect++ } m[v]-- } arrayS := []byte(s) minStart, minLength := 0, math.MaxInt32 okCnt := 0 l, r := 0, 0 tightenLeft := func() { // 收紧左边 for okCnt == espect { v := arrayS[l] l++ m[v]-- // 小于0表示当前字符是需求的字符，且数量已经不满足 if m[v] \u0026lt; 0 { okCnt-- length := r - l + 2 if length \u0026lt; minLength { minLength, minStart = length, l-1 } break } } } // 向右扩展 for r \u0026lt; len(arrayS) { v := arrayS[r] m[v]++ // 等于0表示当前字符是需求的字符，且数量恰好满足 if 0 == m[v] { okCnt++ tightenLeft() } r++ } if minLength != math.MaxInt32 { return string(arrayS[minStart : minStart+minLength]) } return \u0026#34;\u0026#34; } ","date":"2018-11-30T10:53:51+08:00","permalink":"https://www.orztu.com/leetcode/076-minimum-window-substring/","title":"LeetCode 76. Minimum Window Substring"},{"content":"Description Sort Colors\nGiven an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\nNote: You are not suppose to use the library\u0026rsquo;s sort function for this problem.\nExample:\n1 2 3 Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort.\nFirst, iterate the array counting number of 0\u0026rsquo;s, 1\u0026rsquo;s, and 2\u0026rsquo;s, then overwrite array with total number of 0\u0026rsquo;s, then 1\u0026rsquo;s and followed by 2\u0026rsquo;s.\nCould you come up with a one-pass algorithm using only constant space?\n对一个只包含0、1、2三个数字的数组进行排序，要求时间复杂度O(n)，空间复杂度O(1)。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func sortColors(nums []int) { length := len(nums) if length \u0026lt;= 1 { return } l, r := 0, length-1 // 记录 0（红色）的数量 red := 0 for l \u0026lt;= r { fmt.Println(nums[l]) switch nums[l] { case 0: if l != red { // 将第 red 个和第 l 个交换 // 因为 red 表示 0 的数量，所以第 red 个应该是被跳过的 1 nums[l], nums[red] = nums[red], nums[l] } red++ fallthrough case 1: // 遇到 1 （白色）则跳过 l++ case 2: // 遇到 2 （蓝色）则交换到末尾，并且 r--，l 不动 nums[r], nums[l] = nums[l], nums[r] r-- } } } ","date":"2018-11-29T10:50:23+08:00","permalink":"https://www.orztu.com/leetcode/075-sort-colors/","title":"LeetCode 75. Sort Colors"},{"content":"Description Search a 2D Matrix\nWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\nIntegers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1:\n1 2 3 4 5 6 7 8 9 10 11 12 Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true target = 13 Output: false 矩阵中有序存地放着一些数字，查找是否存在某个数字。\nSolution 二分法（Binary Search） 下面代码使用两次二分查找，先找出在哪一行，再对该行进行二分查找。\n亦有先计算元素个数：total = m x n，再对total进行二分查找的解法。\n设二分时所以为index，对应元素坐标为(index/m, index%m)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func searchMatrix(matrix [][]int, target int) bool { l, r := 0, len(matrix)-1 // 先二分查找在哪一行 for l \u0026lt; r { m := r - (r-l)/2 if target \u0026gt;= matrix[m][0] { l = m } else { r = m - 1 } } // conner case if l \u0026gt; len(matrix)-1 { return false } row := matrix[l] l, r = 0, len(row)-1 // 再在对应行中进行二分查找 for l \u0026lt;= r { m := l + (r-l)/2 if target == row[m] { return true } if target \u0026gt; row[m] { l = m + 1 } else { r = m - 1 } } return false } ","date":"2018-11-28T15:07:51+08:00","permalink":"https://www.orztu.com/leetcode/074-search-a-2d-matrix/","title":"LeetCode 74. Search a 2D Matrix"},{"content":"Description Set Matrix Zeroes\nGiven a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.\nExample 1:\n1 2 3 4 5 6 7 8 9 10 11 12 Input: [ [1,1,1], [1,0,1], [1,1,1] ] Output: [ [1,0,1], [0,0,0], [1,0,1] ] Example 2:\n1 2 3 4 5 6 7 8 9 10 11 12 Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] Follow up:\nA straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? 在m x n的矩阵中，如果一个元素为0，则将它所在的行和列都置为0。\nSolution 要解决只使用O(1)空间问题，根据提示可以使用第一行和第一列暂存标记，最后再将对应的行和列置 0。\n但是需要处理第一行和第一列本身需要置 0 的情况，第一行和第一列的标记需要另外存放。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 func setZeroes(matrix [][]int) { // 用于保存第一行和第一列是否需要置0 firstRow, firstCol := false, false row := len(matrix) col := len(matrix[0]) // 检查第一列是否有0 for i := 0; i \u0026lt; row; i++ { if matrix[i][0] == 0 { firstCol = true break } } // 检查第一行是否有0 for i := 0; i \u0026lt; col; i++ { if matrix[0][i] == 0 { firstRow = true } } for i := 1; i \u0026lt; row; i++ { for j := 1; j \u0026lt; col; j++ { if matrix[i][j] == 0 { // 使用第一列标记当前行需要置0 matrix[i][0] = 0 // 使用第一行标记当前列需要置0 matrix[0][j] = 0 } } } // 检查第一列的标记 for i := 1; i \u0026lt; row; i++ { if matrix[i][0] == 0 { for j := 1; j \u0026lt; col; j++ { matrix[i][j] = 0 } } } // 检查第一行的标记 for j := 1; j \u0026lt; col; j++ { if matrix[0][j] == 0 { for i := 1; i \u0026lt; row; i++ { matrix[i][j] = 0 } } } // 将第一列置0 if firstCol { for i := 0; i \u0026lt; row; i++ { matrix[i][0] = 0 } } // 将第一行置0 if firstRow { for i := 0; i \u0026lt; col; i++ { matrix[0][i] = 0 } } } ","date":"2018-11-28T14:33:12+08:00","permalink":"https://www.orztu.com/leetcode/073-set-matrix-zeroes/","title":"LeetCode 73. Set Matrix Zeroes"},{"content":"Description Edit Distance\nGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2.\nYou have the following 3 operations permitted on a word:\nInsert a character Delete a character Replace a character Example 1:\nInput: word1 = \u0026ldquo;horse\u0026rdquo;, word2 = \u0026ldquo;ros\u0026rdquo;\nOutput: 3\nExplanation:\nhorse -\u0026gt; rorse (replace \u0026lsquo;h\u0026rsquo; with \u0026lsquo;r\u0026rsquo;)\nrorse -\u0026gt; rose (remove \u0026lsquo;r\u0026rsquo;)\nrose -\u0026gt; ros (remove \u0026rsquo;e\u0026rsquo;)\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt; \u0026gt; **Example 2:** \u0026gt; \u0026gt; ``` Input: word1 = \u0026#34;intention\u0026#34;, word2 = \u0026#34;execution\u0026#34; Output: 5 Explanation: intention -\u0026gt; inention (remove \u0026#39;t\u0026#39;) inention -\u0026gt; enention (replace \u0026#39;i\u0026#39; with \u0026#39;e\u0026#39;) enention -\u0026gt; exention (replace \u0026#39;n\u0026#39; with \u0026#39;x\u0026#39;) exention -\u0026gt; exection (replace \u0026#39;n\u0026#39; with \u0026#39;c\u0026#39;) exection -\u0026gt; execution (insert \u0026#39;u\u0026#39;) Solution 设最短距离方法为f：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 反推： f(\u0026#34;horse\u0026#34;, \u0026#34;ros\u0026#34;) = 1 + min(f(\u0026#34;hors\u0026#34;, \u0026#34;ros\u0026#34;), // 删除 hors[e] f(\u0026#34;horse\u0026#34;, \u0026#34;ro\u0026#34;), // 插入 ro[s] f(\u0026#34;hors\u0026#34;, \u0026#34;ro\u0026#34;)) // 替换 hors[e] ro[s] f(\u0026#34;hors\u0026#34;, \u0026#34;ros\u0026#34;) = 1 + min(f(\u0026#34;hor\u0026#34;, \u0026#34;ros\u0026#34;), // 删除 hor[s] f(\u0026#34;hors\u0026#34;, \u0026#34;ro\u0026#34;), // 插入 ro[s] f(\u0026#34;hor\u0026#34;, \u0026#34;ro\u0026#34;)) // 替换 hor[s] ro[s] ... 特殊情况和边界条件： 如果最后一个字符相同，则不用操作，distance = 0 如果其中一个字符串为空，则 distance = 另一个字符串长度 解释：\n删除hors[e]：通过f(\u0026quot;hors\u0026quot;, \u0026quot;ros\u0026quot;)将hors变成ros，则有rose删除最后一位得到ros 插入ro[s]：通过f(\u0026quot;horse\u0026quot;, \u0026quot;ro\u0026quot;)将horse变成ro，则插入一位s得到ros 替换替换 hors[e] ro[s]：通过f(\u0026quot;hors\u0026quot;, \u0026quot;ro\u0026quot;)将hors变成ro，则有roe替换最后一位得到ros 递归（Recursive） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 func min(a, b int) int { if a \u0026lt; b { return a } return b } func min3(a, b, c int) int { return min(min(a, b), c) } func minDistance(word1, word2 string) int { w1, w2 := []byte(word1), []byte(word2) l1, l2 := len(w1), len(w2) cache := make([][]int, l1) for i := 0; i \u0026lt; l1; i++ { cache[i] = make([]int, l2) } var solve func(int, int) int solve = func(l1, l2 int) int { if l1 == 0 || l2 == 0 { return l1 + l2 } idx1, idx2 := l1-1, l2-1 if cache[idx1][idx2] \u0026gt;= 1 { // 缓存减一后返回 return cache[idx1][idx2] - 1 } var r int if w1[idx1] == w2[idx2] { // 末位相等 r = solve(l1-1, l2-1) } else { r = 1 + min3(solve(l1-1, l2), // 删除 solve(l1, l2-1), // 插入 solve(l1-1, l2-1)) // 替换 } // 避免需要初始化成`-1` // 加一后缓存 cache[idx1][idx2] = r + 1 return r } return solve(l1, l2) } 动态规划（Dynamic Programming） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func minDistance(word1 string, word2 string) int { l1, l2 := len(word1), len(word2) if l1 == 0 || l2 == 0 { return l1 + l2 } matrix := make([][]int, l1+1) for i := 0; i \u0026lt;= l1; i++ { matrix[i] = make([]int, l2+1) matrix[i][0] = i } for i := 0; i \u0026lt;= l2; i++ { matrix[0][i] = i } w1, w2 := []byte(word1), []byte(word2) for i := 1; i \u0026lt;= l1; i++ { for j := 1; j \u0026lt;= l2; j++ { if w1[i-1] == w2[j-1] { matrix[i][j] = matrix[i-1][j-1] } else { matrix[i][j] = 1 + min3(matrix[i-1][j-1], matrix[i][j-1], matrix[i-1][j]) } } } return matrix[l1][l2] } ","date":"2018-11-27T10:51:41+08:00","permalink":"https://www.orztu.com/leetcode/072-edit-distance/","title":"LeetCode 72. Edit Distance"},{"content":"Description Climbing Stairs\nYou are climbing a stair case. It takes n steps to reach to the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nNote: Given n will be a positive integer.\nExample 1:\n1 2 3 4 5 Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2:\n1 2 3 4 5 6 Input: 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step 好像网上讲动态规划经常举例的题目。\n爬楼梯，可以一次爬一格或者两格，问有多少种不同的方式爬到顶。\nSolution 与《63. Unique Paths II》非常相似。\n到达第n格可以通过第n-1格爬一格和第n-2格爬两格，两种方式达到。\n所以有：\n$$ f(n) = f(n-1) + f(n-2) $$动态规划（Dynamic Programming） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func climbStairs(n int) int { steps := []int{0, 1, 2} if n \u0026lt;= 2 { return steps[n] } for i := 2; i \u0026lt; n; i++ { // tmp := steps[2] // steps[2] = steps[1] + steps[2] // steps[1] = tmp steps[1], steps[2] = steps[2], steps[1]+steps[2] } return steps[2] } 递归（Recursive） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func climbStairs(n int) int { // f(n) = f(n-1) + f(n-2) // f(n-1) = f(n-2) + f(n-3) // 为了避免计算两次f(n-2) 增加缓存 m := map[int]int{1: 1, 2: 2} var solve func(int) int solve = func(n int) int { if num, ok := m[n]; ok { return num } m[n] = solve(n-1) + solve(n-2) return m[n] } return solve(n) } Similar Problem 63. Unique Paths II ","date":"2018-11-26T09:11:58+08:00","permalink":"https://www.orztu.com/leetcode/070-climbing-stairs/","title":"LeetCode 70. Climbing Stairs"},{"content":"Description Sqrt(x)\nImplement int sqrt(int x).\nCompute and return the square root of x, where x is guaranteed to be a non-negative integer.\nSince the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.\nExample 1:\n1 2 Input: 4 Output: 2 Example 2:\n1 2 3 4 Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 整型“开方”\n根据题意，mySqrt(x) = floor(sqrt(x))\nSolution 使用二分法进行查找\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func mySqrt(x int) int { if x == 0 { return 0 } left, right := 1, x/2 for left \u0026lt; right { m := right - (right-left)/2 if m*m \u0026gt; x { right = m - 1 } else { left = m } } return left } Similar Problem 50. Pow(x, n) ","date":"2018-11-23T14:51:19+08:00","permalink":"https://www.orztu.com/leetcode/069-sqrt-x/","title":"LeetCode 69. Sqrt(x)"},{"content":"Description Text Justification\nGiven an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left justified and no extra space is inserted between words.\nNote:\nA word is defined as a character sequence consisting of non-space characters only. Each word\u0026rsquo;s length is guaranteed to be greater than 0 and not exceed maxWidth. The input array words contains at least one word. Example 1:\n1 2 3 4 5 6 7 8 9 Input: words = [\u0026#34;This\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;an\u0026#34;, \u0026#34;example\u0026#34;, \u0026#34;of\u0026#34;, \u0026#34;text\u0026#34;, \u0026#34;justification.\u0026#34;] maxWidth = 16 Output: [ \u0026#34;This is an\u0026#34;, \u0026#34;example of text\u0026#34;, \u0026#34;justification. \u0026#34; ] Example 2:\n1 2 3 4 5 6 7 8 9 10 11 12 Input: words = [\u0026#34;What\u0026#34;,\u0026#34;must\u0026#34;,\u0026#34;be\u0026#34;,\u0026#34;acknowledgment\u0026#34;,\u0026#34;shall\u0026#34;,\u0026#34;be\u0026#34;] maxWidth = 16 Output: [ \u0026#34;What must be\u0026#34;, \u0026#34;acknowledgment \u0026#34;, \u0026#34;shall be \u0026#34; ] Explanation: Note that the last line is \u0026#34;shall be \u0026#34; instead of \u0026#34;shall be\u0026#34;, because the last line must be left-justified instead of fully-justified. Note that the second line is also left-justified becase it contains only one word. Example 3:\n1 2 3 4 5 6 7 8 9 10 11 12 13 Input: words = [\u0026#34;Science\u0026#34;,\u0026#34;is\u0026#34;,\u0026#34;what\u0026#34;,\u0026#34;we\u0026#34;,\u0026#34;understand\u0026#34;,\u0026#34;well\u0026#34;,\u0026#34;enough\u0026#34;,\u0026#34;to\u0026#34;,\u0026#34;explain\u0026#34;, \u0026#34;to\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;computer.\u0026#34;,\u0026#34;Art\u0026#34;,\u0026#34;is\u0026#34;,\u0026#34;everything\u0026#34;,\u0026#34;else\u0026#34;,\u0026#34;we\u0026#34;,\u0026#34;do\u0026#34;] maxWidth = 20 Output: [ \u0026#34;Science is what we\u0026#34;, \u0026#34;understand well\u0026#34;, \u0026#34;enough to explain to\u0026#34;, \u0026#34;a computer. Art is\u0026#34;, \u0026#34;everything else we\u0026#34;, \u0026#34;do \u0026#34; ] Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func fullJustify(words []string, maxWidth int) []string { buildLine := func(end, lineLen int) string { // 只有一个单词 if end == 1 { return words[0] + strings.Repeat(\u0026#34; \u0026#34;, maxWidth-lineLen) } space := maxWidth - lineLen for i := 0; space \u0026gt; 0; space-- { words[i%(end-1)] += \u0026#34; \u0026#34; i++ } return strings.Join(words[:end], \u0026#34;\u0026#34;) } result := []string{} curLen, wordLen := 0, 0 for i := 0; i \u0026lt; len(words); i++ { wordLen = len(words[i]) // i 表示单词个数减一，等于单词之间单个空格数量 if i+curLen+wordLen \u0026gt; maxWidth { result = append(result, buildLine(i, curLen)) i, curLen, words = 0, wordLen, words[i:] } else { curLen += wordLen } } // build last line lastLine := strings.Join(words, \u0026#34; \u0026#34;) if len(lastLine) \u0026lt; maxWidth { lastLine += strings.Repeat(\u0026#34; \u0026#34;, maxWidth-len(lastLine)) } result = append(result, lastLine) return result } ","date":"2018-11-23T14:26:13+08:00","permalink":"https://www.orztu.com/leetcode/068-text-justification/","title":"LeetCode 68. Text Justification"},{"content":"Plus One Description Plus One\n给定一个用数组表示的十进制数，将数字加一。\nExample 1:\n1 2 3 Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Example 2:\n1 2 3 Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. Solution 1 2 3 4 5 6 7 8 9 10 11 func plusOne(digits []int) []int { for i := len(digits) - 1; i \u0026gt;= 0; i-- { if digits[i] != 9 { digits[i]++ return digits } digits[i] = 0 } return append([]int{1}, digits...) } Add Binary Discription Add Binary\n将两个二进制字符串相加\nExample 1:\n1 2 Input: a = \u0026#34;11\u0026#34;, b = \u0026#34;1\u0026#34; Output: \u0026#34;100\u0026#34; Example 2:\n1 2 Input: a = \u0026#34;1010\u0026#34;, b = \u0026#34;1011\u0026#34; Output: \u0026#34;10101\u0026#34; Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 func addBinary(a string, b string) string { aLen := len(a) bLen := len(b) limit := aLen if bLen \u0026gt; limit { limit = bLen } s := make([]byte, limit+1) var carry byte var idx int for i := 1; i \u0026lt;= limit; i++ { idx = aLen - i if idx \u0026gt;= 0 { carry += a[idx] - \u0026#39;0\u0026#39; } idx = bLen - i if idx \u0026gt;= 0 { carry += b[idx] - \u0026#39;0\u0026#39; } // 因为 s 长度为 limit+1，所以需要 limit-i+1 s[limit-i+1] = carry\u0026amp;0x01 + \u0026#39;0\u0026#39; carry \u0026gt;\u0026gt;= 1 } // 起初 s 申请的长度为 limit：make([]byte, limit) // 然后判断 carry 为 1 的时候 s = append([]byte{\u0026#39;1\u0026#39;}, s...) // 这样导致第二次申请内存，耗时增加 // 所以直接申请 limit + 1 长度，返回时少返回一位 if carry == 0 { return string(s[1:]) } s[0] = \u0026#39;1\u0026#39; return string(s) } ","date":"2018-11-23T09:54:07+08:00","permalink":"https://www.orztu.com/leetcode/066-and-067/","title":"LeetCode 66. Plus One \u0026 67. Add Binary"},{"content":"Description Minimum Path Sum\nGiven a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nExample:\n1 2 3 4 5 6 7 8 Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum. 每个格子的数字表示经过它所需的消耗大小。寻找从左上到右下的最少路径消耗。\nSolution 似曾相识 本题与《63. Unique Paths II》\n使用相同的方法：\n要到达右下角，需要经过左边或者上边的格子，而最少消耗自然是从这两个格子中选择到达它们所需消耗（非它们自身消耗）较少的一个：\n$$ f(x, y) = cost_{(x,y)} + min(f(x-1, y), f(x, y-1)) $$所以与之前一样，从左上开始往右下分别计算出每个格子的最少消耗，直到最终格子。\nCode Here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 func minPathSum(grid [][]int) int { row := len(grid) if row == 0 { return 0 } col := len(grid[0]) if col == 0 { return 0 } var left, up, minCost, upCost int // 从第二个格子开始 j := 1 for i := 0; i \u0026lt; row; i++ { for ; j \u0026lt; col; j++ { minCost = -1 left = j - 1 if left \u0026gt;= 0 { // 左边消耗 minCost = grid[i][left] } up = i - 1 if up \u0026gt;= 0 { // 上边消耗 upCost = grid[up][j] if upCost \u0026lt; minCost || minCost == -1 { minCost = upCost } } // 选择较少消耗的路径并加上自身消耗 // 保存当前格子消耗 grid[i][j] += minCost } j = 0 } // 返回最后一个格子消耗 return grid[row-1][col-1] } Similar Problem 63. Unique Paths II ","date":"2018-11-22T14:44:37+08:00","permalink":"https://www.orztu.com/leetcode/064-minimum-path-sum/","title":"LeetCode 64. Minimum Path Sum"},{"content":"Description Unique Paths II\nA robot is located at the top-left corner of a m x n grid (marked \u0026lsquo;Start\u0026rsquo; in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \u0026lsquo;Finish\u0026rsquo; in the diagram below).\nNow consider if some obstacles are added to the grids. How many unique paths would there be?\nAn obstacle and empty space is marked as 1 and 0 respectively in the grid.\nNote: m and n will be at most 100.\nExample 1:\n1 2 3 4 5 6 7 8 9 10 11 12 Input: [ [0,0,0], [0,1,0], [0,0,0] ] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -\u0026gt; Right -\u0026gt; Down -\u0026gt; Down 2. Down -\u0026gt; Down -\u0026gt; Right -\u0026gt; Right 给出地图，求左上角到右下角的路径数量（只能向下或向右移动）。\n其中地图中1表示障碍，无法通过。\nSolution 动态规划（Dynamic Programming） 要到达最后一个格子，只能通过它左边和上边两个格子到达，\n那么达到它的路径数量等于到达左边和上边两个格子的路径数量相加。\n依此类推，到达左边和上边两个格子的路径数量又分别等于它们的左边和上边两条路径之和。\n最终我们将反推到第一个格子，它的路径数量只有一条。\n其中第一排和第一列稍微特殊，它们只有一条路径可以到达。\n所以当前格子路径数量：\n$$ f(x, y) = f(x-1, y) + f(x, y-1) $$通过这个公式可以写出对应的递归方法。\n更简便的方法是从左上方格子开始，向后计算每个格子的路径数量，直到最后一个格子。\nExample 比如地图4x3的地图，将第一个格子路径数量标记为1，然后依次标记后边的格子，得到达到最后一个格子的路径数量为10：\n1 2 3 0, 0, 0, 0 1, 1, 1, 1 0, 0, 0, 0 ==\u0026gt; 1, 2, 3, 4 0, 0, 0, 0 1, 3, 6, 10 现在假设有一个障碍，只需要在遇到障碍时，将障碍的路径数量标记为0即可：\n1 2 3 0, 0, 0, 0 1, 1, 1, 1 0, 0, 1, 0 ==\u0026gt; 1, 2, 0, 1 0, 0, 0, 0 1, 3, 3, 4 Code Here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 func uniquePathsWithObstacles(obstacleGrid [][]int) int { row := len(obstacleGrid) if row == 0 { return 0 } col := len(obstacleGrid[0]) if col == 0 || obstacleGrid[0][0] == 1 { return 0 } var left, up int var ways int // 标记第一格到达路径数量为1 obstacleGrid[0][0] = 1 j := 1 // 从第二个格子开始 for i := 0; i \u0026lt; row; i++ { for ; j \u0026lt; col; j++ { // 如果为障碍，标记当前格子达到路径数量为 0 if obstacleGrid[i][j] == 1 { obstacleGrid[i][j] = 0 continue } // 表示当前格子到达路径数量 // 它等于左边格子路径数量+上边格子路径数量 ways = 0 left = j - 1 if left \u0026gt;= 0 { // 加上左边格子路径数量 // ways += leftWays ways = obstacleGrid[i][left] } up = i - 1 if up \u0026gt;= 0 { // 加上上边格子路径数量 ways += obstacleGrid[up][j] } // 保存当前格子路径数量 obstacleGrid[i][j] = ways } j = 0 } // 返回最后一个格子路径数量 return obstacleGrid[row-1][col-1] } Similar Problem 62. Unique Paths ","date":"2018-11-22T09:06:11+08:00","permalink":"https://www.orztu.com/leetcode/063-unique-paths-ii/","title":"LeetCode 63. Unique Paths II"},{"content":"Description Pow(x, n)\nImplement pow(x, n), which calculates x raised to the power n (x^n).\nExample 1:\n1 2 Input: 2.00000, 10 Output: 1024.00000 Example 2:\n1 2 Input: 2.10000, 3 Output: 9.26100 Example 3:\n1 2 3 Input: 2.00000, -2 Output: 0.25000 Explanation: 2^{-2} = {1/2}^2 = 1/4 = 0.25 Note:\n-100.0 \u0026lt; x \u0026lt; 100.0 n is a 32-bit signed integer, within the range [−2^31, 2^31 − 1] 求x的n次方。\nSolution 使用分治法将n次方分解为n/2次方问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 func myPow(x float64, n int) float64 { if x == 0 || x == 1 { return x } else if n == 0 { return 1 } else if n \u0026lt; 0 { return myPow(1/x, -n) } else if n\u0026amp;1 == 0 { return myPow(x*x, n/2) } else { return x * myPow(x*x, n/2) } } Similar Problem 69. Sqrt(x) ","date":"2018-11-21T15:27:28+08:00","permalink":"https://www.orztu.com/leetcode/050-pow/","title":"LeetCode 50. Pow(x, n)"},{"content":"Description There is now a string s consisting of only numbers and lowercase letters.\nIf the string s is interesting, then s must be split into several substrings, each substring satisfies the beginning of the number, and the number represents the number of characters after it. For example, s = \u0026ldquo;4g12y6hunter\u0026rdquo;, we can divide it into \u0026ldquo;4g12y\u0026rdquo; and \u0026ldquo;6hunter\u0026rdquo;, so the string is interesting.\nIf s is an interesting string, output \u0026ldquo;yes\u0026rdquo;, otherwise output \u0026ldquo;no\u0026rdquo;\nExample:\ns = \u0026quot;124gray6hunter\u0026quot;,return \u0026quot;yes\u0026quot;\n1 we can divide it into \u0026#34;12\u0026#34;, \u0026#34;4gray\u0026#34;, \u0026#34;6hunter\u0026#34;. s = \u0026quot;31ba2a\u0026quot; ,return \u0026quot;no\u0026quot;\n判断字符串s是否“有趣”。\n有趣：字符串可以被分成多组，每组前面的数字等于剩余字符的长度。\nSolution 本题主要在于需要识别连续数字，比如11需要理解为十一。\n使用BFS实现：识别数字，跳过对应长度的字符后，将下一个检查点加入队列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 \u0026lt;!-- tab golang --\u0026gt; func check(s string) string { sLength := len(s) if sLength \u0026lt;= 0 { return \u0026#34;no\u0026#34; } queue := []int{0} var idx, n, num, nextIdx int for len(queue) \u0026gt; 0 { // pop front idx = queue[0] queue = queue[1:] n = 0 for idx \u0026lt; sLength { num = int(s[idx] - byte(\u0026#39;0\u0026#39;)) if num \u0026lt; 0 || num \u0026gt; 9 { break } n = n*10 + num // 从当前位置向后跳过 n 个字符 // 并且检查下一个字符是否为数字或者恰好结束 nextIdx = idx + n + 1 if nextIdx \u0026gt; sLength { break } else if nextIdx == sLength { // 当前位置恰好结束 return \u0026#34;yes\u0026#34; } else if nextIdx != idx { // push back queue = append(queue, nextIdx) } idx++ } } return \u0026#34;no\u0026#34; } \u0026lt;!-- endtab --\u0026gt; \u0026lt;!-- tab cpp --\u0026gt; class Solution { public: /** * @param s: the string s * @return: check if the string is interesting */ string check(string \u0026amp;s) { // Write your code here int sLength = s.length(); if (sLength == 0) { return \u0026#34;no\u0026#34;; } queue\u0026lt;int\u0026gt; q; q.push(0); int idx, n, num, nextIdx; while (q.size() \u0026gt; 0) { // pop front int idx = q.front(); q.pop(); n = 0; for (; idx \u0026lt; sLength; idx++) { num = s[idx] - (int)\u0026#39;0\u0026#39;; if (num \u0026lt; 0 || num \u0026gt; 9) { break; } n = n*10 + num; // 从当前位置向后跳过 n 个字符 // 并且检查下一个字符是否为数字或者恰好结束 nextIdx = idx + n + 1; if (nextIdx \u0026gt; sLength) { break; } else if (nextIdx == sLength) { // 当前位置恰好结束 return \u0026#34;yes\u0026#34;; } else if (nextIdx != idx) { // push back q.push(nextIdx); } } } return \u0026#34;no\u0026#34;; } }; \u0026lt;!-- endtab --\u0026gt; ","date":"2018-11-20T09:53:28+08:00","permalink":"https://www.orztu.com/lintcode/1630-interesting-string/","title":"LintCode 1630. Interesting String"},{"content":"Description Rotate List\nGiven a linked list, rotate the list to the right by k places, where k is non-negative.\nExample 1:\n1 2 3 4 5 Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, k = 2 Output: 4-\u0026gt;5-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;NULL Explanation: rotate 1 steps to the right: 5-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;NULL rotate 2 steps to the right: 4-\u0026gt;5-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;NULL Example 2:\n1 2 3 4 5 6 7 Input: 0-\u0026gt;1-\u0026gt;2-\u0026gt;NULL, k = 4 Output: 2-\u0026gt;0-\u0026gt;1-\u0026gt;NULL Explanation: rotate 1 steps to the right: 2-\u0026gt;0-\u0026gt;1-\u0026gt;NULL rotate 2 steps to the right: 1-\u0026gt;2-\u0026gt;0-\u0026gt;NULL rotate 3 steps to the right: 0-\u0026gt;1-\u0026gt;2-\u0026gt;NULL rotate 4 steps to the right: 2-\u0026gt;0-\u0026gt;1-\u0026gt;NULL 从倒数第k个结点位置旋转链表：首尾相连，以倒数第k个结点为新head。\nSolution 这种寻找链表倒数第k的方法，通常使用快慢指针。\n快指针先前进k个结点，然后两个指针同时前进，当到快指针达链表尾部时，\n两个指针相差k个结点，此时慢指针指向倒数第k个结点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 func rotateRight(head *ListNode, k int) *ListNode { if head == nil || k == 0 { return head } fast := \u0026amp;ListNode{ Next: head, } slow := fast // fast 先前进 steps := 0 for steps \u0026lt; k { fast = fast.Next steps++ if fast.Next == nil { k = k % steps if k == 0 { return head } steps = 0 fast = slow } } // 再同时前进 for fast.Next != nil { fast = fast.Next slow = slow.Next } fast.Next = head head = slow.Next slow.Next = nil return head } ","date":"2018-11-19T14:37:06+08:00","permalink":"https://www.orztu.com/leetcode/061-rotate-list/","title":"LeetCode 61. Rotate List"},{"content":"Description Permutation Sequence\nThe set [1,2,3,...,n] contains a total of n! unique permutations.\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n\u0026quot;123\u0026quot; \u0026quot;132\u0026quot; \u0026quot;213\u0026quot; \u0026quot;231\u0026quot; \u0026quot;312\u0026quot; \u0026quot;321\u0026quot; Given n and k, return the k-th permutation sequence.\nNote:\nGiven n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive. Example 1:\n1 2 Input: n = 3, k = 3 Output: \u0026#34;213\u0026#34; Example 2:\n1 2 Input: n = 4, k = 9 Output: \u0026#34;2314\u0026#34; 假设存在长度为n的数组：[1,2,3,...,n]，输出第k个排列。\nSolution 一个长度为n的数组，总共有n!种排列。假设第一个数字固定后，剩余(n-1)!种排列。\n上图中的字典序树可以更直观的看出，\n在n=4:[1,2,3,4]中，\n“第零层”包含4!=24个叶子，\n第一层包含3!=6个叶子，\n第二层包含2!=2个叶子\u0026hellip;\n假设现在要查找第k=9个排列（第九个叶子），第一层应该经过第⌈9/3!⌉ 个分支，即ceil(k/(n-1)!)。\n由此公式，可以依次求每层分支序号。\n比如k=9，依次经过：\n⌈9 / 3!⌉: 2 ⌈9-3!*(2-1) / 2!⌉: 2 [9-3!*(2-1)-2!*(2-1) / 1!]: 1 1 通过序号：2,2,1,1所经过的分支，可以得到结果：2314\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func getPermutation(n int, k int) string { s := []rune{} total := 1 for i := 1; i \u0026lt;= n; i++ { total *= i s = append(s, rune(i)+rune(\u0026#39;0\u0026#39;)) } ret := make([]rune, n) idx := 0 for n \u0026gt; 0 { // (n-1)! total /= n // 当前层索引 i := (k - 1) / total // 移除 s[i] ret[idx] = s[i] s = append(s[:i], s[i+1:]...) // 减去前面组的数量，得到下一层的索引 k -= total * i idx++ n-- } return string(ret) } Similar Problem 31. Next Permutation ","date":"2018-11-19T10:52:29+08:00","permalink":"https://www.orztu.com/leetcode/060-permutation-sequence/","title":"LeetCode 60. Permutation Sequence"},{"content":"上回提到元表优化 Lua 配置文件，以减少重复字段，节省内存开销。\n除了这种直接地减少内存开销的方法，使用元表还能实现数据的延迟加载，从另一个角度节约内存。\n延迟加载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 -- PropModel.lua PropModel = { [1001] = { ID = 1001, name = \u0026#34;道具1001\u0026#34;, desc = \u0026#34;道具1001描述\u0026#34;, ... }, [1002] = { ID = 1002, name = \u0026#34;道具1002\u0026#34;, desc = \u0026#34;道具1002描述\u0026#34;, ... }, ... } 上面依然是最常见的道具表，所有道具都配置在同一个表中，初始化时会全部加载进内存。\n然而大多数道具是玩家并不拥有的，在内存中长期停留浪费空间。\n通过使用元表，我们能做到每个道具按需（延迟）加载。\n首先清空表数据，使用元表的__index方法实现延迟加载：\n1 2 3 4 5 6 7 8 9 10 11 -- PropModel.lua PropModel = {} -- 道具表不再直接存放数据 -- 使用元表延迟加载数据 setmetatable(PropModel, { __index = function(t, k) local item = require(string.format(\u0026#34;PropModel_%s\u0026#34;, k)) PropModel[k] = item return item end, }) 将各道具数据另外存放——将道具1001单独存放：\n1 2 3 4 5 6 7 8 -- PropModel_1001.lua local PropModel_1001 = { ID = 1001, name = \u0026#34;道具1001\u0026#34;, desc = \u0026#34;道具1002描述\u0026#34;, ... } return PropModel_1001 最后 上面的代码是每个item单独拆分到一个文件中。\n如果有必要，也可以按照ID进行区间拆分，将多个item放在一个文件中。\n在__index方法中判断ID落在哪个区间，将该区间数据全部加载。\n同时，拆分后的数据依然可以结合上一篇\n的“默认字段”的方法使用。\n","date":"2018-11-16T11:38:00+08:00","permalink":"https://www.orztu.com/post/lua-table-minify-ii/","title":"使用元表优化 Lua 配置文件 II"},{"content":"Description Spiral Matrix II\nGiven a positive integer n, generate a square matrix filled with elements from 1 to n^2 in spiral order.\nExample:\n1 2 3 4 5 6 7 Input: 3 Output: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] Solution This problem is very similar to 54. Spiral Matrix.\nJust replace function append_ans to mark_idx:\n1 2 3 4 5 idx := 1 mark_idx := func(x, y int) { matrix[x][y] = idx idx++ } Similar Problem 54. Spiral Matrix ","date":"2018-11-16T08:54:44+08:00","permalink":"https://www.orztu.com/leetcode/059-spiral-matrix-ii/","title":"LeetCode 59. Spiral Matrix II"},{"content":"Description Length of Last Word\nGiven a string s consists of upper/lower-case alphabets and empty space characters \u0026rsquo; \u0026lsquo;, return the length of last word in the string.\nIf the last word does not exist, return 0.\nNote: A word is defined as a character sequence consists of non-space characters only.\nExample:\n1 2 Input: \u0026#34;Hello World\u0026#34; Output: 5 求给出的字符串中最后一个单词的长度。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func lengthOfLastWord(s string) int { length := 0 for i := len(s) - 1; i \u0026gt;= 0; i-- { if s[i] == \u0026#39; \u0026#39; { // if there are spaces at last, they\u0026#39;ll be skip if length \u0026gt; 0 { break } } else { // there are only alphabets and space // so it\u0026#39;s alphabets now // we don\u0026#39;t need to check if s[i] between \u0026#39;a\u0026#39; to \u0026#39;z\u0026#39; or \u0026#39;A\u0026#39; to \u0026#39;Z\u0026#39; length++ } } return length } ","date":"2018-11-16T08:35:56+08:00","permalink":"https://www.orztu.com/leetcode/058-length-of-last-word/","title":"LeetCode 58. Length of Last Word"},{"content":"Description Insert Interval\nGiven a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\nYou may assume that the intervals were initially sorted according to their start times.\nExample 1:\n1 2 Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2:\n1 2 3 Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. 在给出的有序区间中插入新的区间，需要合并相邻的区间。\nSolution 先找出所有比新区间小的区间 再找出所有比新区间大的区间 在查找过程中将新区间与相邻区间合并 最后返回[小区间]+[新区间]+[大区间] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 func insert(intervals []Interval, newInterval Interval) []Interval { length := len(intervals) if length == 0 { return []Interval{newInterval} } // 分割比 newInterval 小的区间 lEnd := 0 for lEnd \u0026lt; length \u0026amp;\u0026amp; newInterval.Start \u0026gt; intervals[lEnd].End { lEnd++ } // 边界判断 if lEnd == length { return append(intervals, newInterval) } if intervals[lEnd].Start \u0026lt; newInterval.Start { // 将当前区间与 newInterval 合并 newInterval.Start = intervals[lEnd].Start } // 分割比 newInterval 大的区间 rStart := lEnd for rStart \u0026lt; length \u0026amp;\u0026amp; newInterval.End \u0026gt;= intervals[rStart].Start { if intervals[rStart].End \u0026gt; newInterval.End { // 将当前区间与 newInterval 合并 newInterval.End = intervals[rStart].End } rStart++ } // append 时用 newInterval 建立新的 Slice 与 intervals[rStart:] 合并 // 再与 intervals[:lEnd] 合并 // 之前直接将 newInterval append 到 intervals[:lEnd] 后面，再与 intervals[rStart:] 合并 // 会导致 intervals[rStart:] 的内存区域被覆盖 return append(intervals[:lEnd], append([]Interval{newInterval}, intervals[rStart:]...)...) } Similar Problem 56. Merge Intervals ","date":"2018-11-15T16:31:58+08:00","permalink":"https://www.orztu.com/leetcode/057-insert-interval/","title":"LeetCode 57. Insert Interval"},{"content":"Description Merge Intervals\nGiven a collection of intervals, merge all overlapping intervals.\nExample 1:\n1 2 3 Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2:\n1 2 3 Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considerred overlapping. 合并区间重叠/相邻的区间。\nSolution 先对区间进行排序，然后逐个判断是否需要与前一个区间合并。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /** * Definition for an interval. * type Interval struct { * Start int * End int * } */ type IntervalArr []Interval func (h IntervalArr) Len() int { return len(h) } func (h IntervalArr) Less(i, j int) bool { return h[i].Start \u0026lt; h[j].Start } func (h IntervalArr) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func merge(intervals []Interval) []Interval { if len(intervals) == 0 { return nil } // 先对区间进行排序 sort.Sort(IntervalArr(intervals)) ret := make([]Interval, 0) pInter := \u0026amp;intervals[0] for i := 1; i \u0026lt; len(intervals); i++ { curInter := \u0026amp;intervals[i] if pInter.End \u0026gt;= curInter.Start { if pInter.End \u0026lt; curInter.End { // “合并操作” pInter.End = curInter.End } } else { ret = append(ret, *pInter) pInter = curInter } } ret = append(ret, *pInter) return ret } Similar Problem 57. Insert Interval ","date":"2018-11-15T14:49:19+08:00","permalink":"https://www.orztu.com/leetcode/056-merge-intervals/","title":"LeetCode 56. Merge Intervals"},{"content":"Description Jump Game\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nDetermine if you are able to reach the last index.\nExample 1:\n1 2 3 Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:\n1 2 3 4 Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. 给定一个非负整型数组，每个数字表示可以从该位置向后跳跃的最大步数。\n判断是否能从第一个数字开始跳跃到最后一个数字。\nSolution 使用reachable表示当前可跳跃的最远位置； 从第一个位置开始向reachable搜索，并更新reachable； 如果reachable \u0026gt;= len(nums) - 1表示可达最后一个数字。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func canJump(nums []int) bool { target := len(nums) - 1 if target \u0026lt; 0 { return false } // 可到达的最远距离 reachable := 0 // 从 0 到 reachable for i := 0; i \u0026lt;= reachable; i++ { m := nums[i] + i if m \u0026gt; reachable { reachable = m } if reachable \u0026gt;= target { return true } } return reachable \u0026gt;= target } ","date":"2018-11-15T11:29:11+08:00","permalink":"https://www.orztu.com/leetcode/055-jump-game/","title":"LeetCode 55. Jump Game"},{"content":"Description Spiral Matrix\nGiven a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\nExample 1:\n1 2 3 4 5 6 7 Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5] Example 2:\n1 2 3 4 5 6 7 Input: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7] 从外向内螺旋形遍历矩阵。\nSolution 列出遍历的四方边界：left，right，top，bottom；\n每次循环时，边界向中间收紧。\n在循环中，分别遍历上边，右边，底边，左边。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 func spiralOrder(matrix [][]int) []int { // 矩阵有效性判断 row := len(matrix) if row == 0 { return nil } col := len(matrix[0]) if col == 0 { return nil } res := make([]int, row*col) idx := 0 append_ans := func(x, y int) { res[idx] = matrix[x][y] idx++ } // 边界：left, right, top, bottom l, r := 0, col-1 t, b := 0, row-1 for l \u0026lt;= r \u0026amp;\u0026amp; t \u0026lt;= b { // 从左往右遍历top行 for i := l; i \u0026lt;= r; i++ { append_ans(t, i) } // 从上往下遍历right列 for i := t + 1; i \u0026lt; b; i++ { append_ans(i, r) } if t \u0026lt; b { // 从右往左遍历bottom行 for i := r; i \u0026gt;= l; i-- { append_ans(b, i) } } if l \u0026lt; r { // 从下往上遍历left列 for i := b - 1; i \u0026gt; t; i-- { append_ans(i, l) } } // 收紧边界 l++ r-- t++ b-- } return res } Similar Problem 59. Spiral Matrix II ","date":"2018-11-15T10:43:41+08:00","permalink":"https://www.orztu.com/leetcode/054-spiral-matrix/","title":"LeetCode 54. Spiral Matrix"},{"content":"配置文件 在游戏工程中，通常有大量配置是由策划提供，再转换成程序方便读取的格式添加到工程中。\n在我参与的Cocos2dx-Lua工程中，策划通常在Excel中配置，再通过脚本转换为Lua-Table的文件。\n比如常见的道具表转换后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 -- PropModel.lua PropModel = { [1001] = { ID = 1001, name = \u0026#34;道具1001\u0026#34;, desc = \u0026#34;道具1001描述\u0026#34;, colorLv = 1, -- 颜色等级 ifSell = true, -- 是否可以出售 ifUse = true, -- 是否可以使用 useExtraStr = \u0026#34;\u0026#34;, -- 使用时额外消耗的资源 useNeedNum = 1, -- 使用消耗数量 maxNum = 99, -- 最大堆叠数量 ... }, [1002] = { ID = 1002, name = \u0026#34;道具1002\u0026#34;, desc = \u0026#34;道具1002描述\u0026#34;, colorLv = 1, -- 颜色等级 ifSell = true, -- 是否可以出售 ifUse = true, -- 是否可以使用 useExtraStr = \u0026#34;\u0026#34;, -- 使用时额外消耗的资源 useNeedNum = 1, -- 使用消耗数量 maxNum = 99, -- 最大堆叠数量 ... }, ... } Excel配置中每一行数据经过转换后对应Lua-Table的一个item。\n通过观察可以发现其中有部分字段很容易重复，如：colorLv、ifUse、useNeedNum等，\n这些字段通常为枚举或者有固定的分类，只有几个不同的值，然而配置表中每个item都需要为这些内容创建一个字段。\n优化 有了这些重复的字段，就给了我们优化的空间。\n通过使用Lua的元表，可以让每个item拥有共同的字段而非每个item去创建一个字段。\n从而节省内存开销。\n如优化之后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 PropModel = { [1001] = { ID = 1001, name = \u0026#34;道具1001\u0026#34;, desc = \u0026#34;道具1001描述\u0026#34;, ... }, [1002] = { ID = 1002, name = \u0026#34;道具1002\u0026#34;, desc = \u0026#34;道具1002描述\u0026#34;, ... }, ... } -- 将重复内容提取为默认item local default__ = { colorLv = 1, ifSell = true, ifUse = true, useExtraStr = \u0026#34;\u0026#34;, useNeedNum = 1, maxNum = 99, } local base = { __index = default__, } for _, v in pairs(PropModel) do setmetatable(v, base) end 这样为每个item设置元表后，item中的字段数量大幅缩减。\n在实际生产中，这步优化被直接放在脚本中进行。在Excel到Lua-Table的过程中直接完成。\n缺点 可读性变差。开发人员人工检查时需要把数据对应的item和default__组合起来看才能得到当前item的数据。\n","date":"2018-11-06T15:14:38+08:00","permalink":"https://www.orztu.com/post/lua-table-minify/","title":"使用元表优化 Lua 配置文件"},{"content":"Description Unique Paths\nA robot is located at the top-left corner of a m x n grid (marked \u0026lsquo;Start\u0026rsquo; in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \u0026lsquo;Finish\u0026rsquo; in the diagram below).\nHow many possible unique paths are there?\nAbove is a 7 x 3 grid. How many possible unique paths are there?\nNote: m and n will be at most 100.\nExample 1:\n1 2 3 4 5 6 7 Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -\u0026gt; Right -\u0026gt; Down 2. Right -\u0026gt; Down -\u0026gt; Right 3. Down -\u0026gt; Right -\u0026gt; Right Example 2:\n1 2 Input: m = 7, n = 3 Output: 28 在m x n的方格中，从左上角走到右下角的不同路径有几种？（只允许向右和向下走）\nSolution 这道题目可以转换为数学题：\nm x n的方格要从左上角走到右下角，需要经过m - 1次Right和n - 1次Down操作。\n所以总共是m + n - 2次操作，而操作顺序的不同，则对应路径不同。\n这就转换成了数学的排列问题：C(m + n -2, n - 1)。\n在m + n - 2操作中取Down操作的位置，其余位置就是Right操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func uniquePaths(m int, n int) int { total := (m + n - 2) option := n - 1 // C(3, 1) 与 C(3, 2)相等 if m-1 \u0026lt; option { option = m - 1 } if option \u0026lt;= 0 { return 1 } // 计算C(m + n - 2, option) pp, qq := 1, 1 for i := 1; i \u0026lt;= option; i++ { pp *= total qq *= i total-- } return pp / qq } Similar Problem 63. Unique Paths II ","date":"2018-09-10T14:43:03+08:00","permalink":"https://www.orztu.com/leetcode/062-unique-paths/","title":"LeetCode 62. Unique Paths"},{"content":"C 语言与 Golang 相互调用的简单例子。\n在此使用一段简单的代码展示 CGO 的基本用法 —— 在 Go 程序中使用 C 语言编程。\n使用 C 源码编译 项目目录结构：\n1 2 3 4 5 6 project/ - main.go - add/ - add.h - add.c - add.go 在 add.h、add.c 中，分别定义已经实现了两数相加的函数 add：\n1 2 // add.h int add(int a, int b); 1 2 3 4 5 6 // add.c #include \u0026#34;add.h\u0026#34; int add(int a, int b) { return a + b; } 在 add.go 中，对 C 语言实现的函数 add 进行了一次封装，以便外部调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package add /* #include \u0026#34;add.h\u0026#34; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int mul(int a, int b) { return a * b; } */ import \u0026#34;C\u0026#34; import ( \u0026#34;unsafe\u0026#34; ) func HelloWorld() { s := C.CString(\u0026#34;Hello World!\u0026#34;) C.puts(s) C.free(unsafe.Pointer(s)) } func Add(a, b int) int { return int(C.add(C.int(a), C.int(b))) } func Mul(a, b int) int { return int(C.mul(C.int(a), C.int(b))) } 其中的 import \u0026quot;C\u0026quot; 表示使用了 CGO 。在这条语句前面的注释是一段 C 语言代码。\n这里就定义了哪些 C 语言函数被引用。也可以在这里直接编写函数并实现。\n因为这个特殊的语法，import \u0026ldquo;C\u0026rdquo; 必须单独一行，不可与其他包一起引用。\n可以看到在代码中引用了头文件 add.h 以及 C 标准库的头文件，另外还实现了另一个两数相乘的函数 mul。\n在 Golang 中通过使用 C.xxx 的方式调用 C 函数。HelloWorld 展示了对库函数的调用。Add 和 Mul 展示了对自定义函数的调用。\n因为Golang 和 C 有各自的变量类型。所以传参时候需要进行类型转换。\nHelloWorld 在传参时使用 C.CString 将 Golang 字符串类型转换为 C 语言类型。\n因为 C.CString 是在堆上分配空间存放字符串，需要调用者自己释放，所以最后调用 C.free 释放该字符串。\n点击这里获取更多类型转换的知识。\n最后在 main.go 中引用 add 包：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; // import package add \u0026#34;./add\u0026#34; ) func main() { add.HelloWorld() fmt.Println(add.Add(10, 5)) fmt.Println(add.Mul(10, 5)) } 编译运行后可以看到输出：\n1 2 3 Hello World! 15 50 其中 add.c 因为 import ./add 的引用而参与编译。\n使用链接库 除了可以直接使用 C 源码编译 Go 程序，还可以：\n调用 C 导出的静态库/动态库 把 Golang 编译成静态库/动态库供 C 其他程序调用。 点击这里获取另外几种调用方式演示代码\n参考 更多 CGO 知识可以从这里获取\n","date":"2018-09-03T15:56:08+08:00","permalink":"https://www.orztu.com/post/cgo-introduce/","title":"CGO —— Golang 与 C 语言混合编程"},{"content":"govendor go vendor 是 go 1.6 官方正式引入的包管理方式。\n其基本思路是，将引用的外部包的源代码放在当前工程的vendor目录下面，go 编译时会优先从vendor目录寻找依赖关系。\n包状态类型 首先要知道govendor对包状态的分类：\n状态 缩写 含义 +local l packages in your project 本地包，即项目自身的包组织 +external e 被引用、在$GOPATH下找得到、但当前项目不存在的包 +vendor v 已被 govendor 管理，即在 vendor 目录下 +std s 标准库中的包 +excluded x 明确从vendoring中排除的外部包 +unused u 未使用的包，即包在 vendor 目录下，但项目并没有用到 +missing m 代码引用了依赖包，但该包并没有找到 +program p 主程序包，意味着可以编译为执行文件 +outside +external +missing +all 所有的包 常用的三种为：\nexternal: 放在$GOPATH 下被依赖的包（最常用） local: 项目自身的包 vendor: 被govendor管理的，放在vendor目录下的包 命令 命令 功能 init 初始化 vendor 目录 list 列出所有的依赖包 add 添加包到 vendor 目录，如 govendor add +external 添加所有外部包，也可以直接跟包名，如 govendor add golang.org/x/net/internal/socket update 从 $GOPATH 更新依赖包到 vendor 目录 remove 从 vendor 管理中删除依赖（add 的反操作） status 列出所有缺失、过期和修改过的包 fetch 添加或更新包到本地 vendor 目录 sync 本地存在 vendor.json 时候拉去依赖包，匹配所记录的版本 get 类似 go get 目录，拉取依赖包到 vendor 目录 基本操作 govendor status: 查看当前包状态\ngovendor list +e: 查看当前项目的依赖但是未被添加到vendor中的包\ngovendor add +e: 添加依赖的包。如果vendor.json中存在，但是vendor目录下不存在（即govendor status显示缺失）的包也会被重新添加\ngovendor remove +u: 删除在vendor下但是未依赖的包\n在实际过程中，有部分包是团队的公共包。\n这部分包通常有自己的单独项目，并且已经被我们添加到$GOPATH下，可能就不需要添加到当前项目的vendor下。\n这时候可以结合list和add来使用，\n先用list -no-status +e列出依赖包，然后使用grep过滤，再调用add命令添加：\n1 govendor list -no-status +e | grep -v \u0026#39;myteam/common\u0026#39; | xargs govendor add ","date":"2018-08-02T14:43:33+08:00","permalink":"https://www.orztu.com/post/using-govendor/","title":"govendor 使用"},{"content":"由于众所不知的原因，在国内访问golang.org需要爬梯子。\n所以使用go get安装某些包的时候，也要用梯子。\n方法 1. 设置 git 代理 1 git config --global http.proxy socks5://127.0.0.1:9527 2. 通过代理 go get socks5 代理：\n1 http_proxy=socks5://127.0.0.1:9527 go get golang.org/x/tools/cmd/goimports 3. 取消 git 代理 1 git config --global --unset http.proxy http 代理 如果是 http 代理，将socks5://改为http://\n","date":"2018-08-02T09:47:52+08:00","permalink":"https://www.orztu.com/post/go-get-through-a-proxy/","title":"go get through a proxy"},{"content":"First Missing Positive\nDescription Given an unsorted integer array, find the smallest missing positive integer.\nExample 1:\n1 2 Input: [1,2,0] Output: 3 Example 2:\n1 2 Input: [3,4,-1,1] Output: 2 Example 3:\n1 2 Input: [7,8,9,11,12] Output: 1 Note:\nYour algorithm should run in O(n) time and uses constant extra space. 使用O(n)的时间复杂度和O(1)的空间在无序数组中查找第一个缺失的正数。\nSolution 此题关键在于利用数字直接寻找其位置，达到排序目的。\n假设有数组[4, 3, 5, 1]：\n取第一个数4，检查4是否在第4个位置：否，与第四个位置数字交换得到[1, 3, 5, 4]。\n交换后继续判断当前数字1是否在第1个位置：是，则跳过。\n依次判断之后得到数组[1, 5, 3, 4]。其中遇到5时因为其超过数组长度，直接跳过。\n再次从第一个位置开始判断，找到第一个位置与数字不符合的地方即为缺失的数字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func firstMissingPositive(nums []int) int { l := len(nums) // 进行排序 for i := 0; i \u0026lt; l; { n := nums[i] if n \u0026lt;= 0 || n \u0026gt; l { // 溢出的不用管 i++ } else if i+1 != n \u0026amp;\u0026amp; nums[n-1] != n { // 判断当前数字是否在它应该的位置上 // 数字 n 应该在[n - 1]上 // 需要处理目标位置与当前位置数字相同，否则死循环 nums[i] = nums[n-1] nums[n-1] = n // 交换位置后，继续处理当前位置上的数字，不需要i++ } else { // 处理下一个位置 i++ } } // 查找第一个不符合的数字 for i := 0; i \u0026lt; l; i++ { if nums[i] != i+1 { return i + 1 } } return l + 1 } ","date":"2018-07-27T08:59:07+08:00","permalink":"https://www.orztu.com/leetcode/041-first-missing-positive/","title":"LeetCode 41. First Missing Positive"},{"content":"Multiply Strings\nDescription Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nExample 1:\nInput: num1 = \u0026ldquo;2\u0026rdquo;, num2 = \u0026ldquo;3\u0026rdquo;\nOutput: \u0026ldquo;6\u0026rdquo;\nExample 2:\nInput: num1 = \u0026ldquo;123\u0026rdquo;, num2 = \u0026ldquo;456\u0026rdquo;\nOutput: \u0026ldquo;56088\u0026rdquo;\n将两个字符串表示的数字相乘（大数相乘）。\nNote:\nThe length of both num1 and num2 is \u0026lt; 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly. 实现大数相乘：以string的形式给出两个非负整数，求乘积。\nSolution 我在实现这个乘法时，按照手写计算的方式，每次按位相乘之后记录进位然后写下当前位。\n然后把当前位结果加上前一位的结果并存为byte。每次外循环都会做一次大数加法，将乘积结果累加。\n效率很不理想：40ms。\n在看了别人的算法之后，重新实现了一遍。\n先将每一位的乘法结果保存，最后再按位相加并处理进位。\n这里贴出别人的算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 func multiply(num1 string, num2 string) string { l1, l2 := len(num1), len(num2) // 需要使用int，使用byte会在按位相加的时候溢出 r := make([]int16, l1+l2) idx := 0 for i1 := l1 - 1; i1 \u0026gt;= 0; i1-- { // num1的个位数从最后一位开始写； // num1的十位数从倒数第二位开始写； // num2的百位数从倒数第三位开始写 // ... // so: l1 + l2 - 1 - (l1 - i1 - 1) idx = l2 + i1 for i2 := l2 - 1; i2 \u0026gt;= 0; i2-- { r[idx] += int16(num1[i1]-\u0026#39;0\u0026#39;) * int16(num2[i2]-\u0026#39;0\u0026#39;) idx-- } } // 按位相加并进位 for idx = len(r) - 1; idx \u0026gt;= 0; idx-- { if r[idx] \u0026gt; 9 { r[idx-1] += (r[idx] / 10) r[idx] %= 10 } } var buf bytes.Buffer // truncate front \u0026#39;0\u0026#39; for _, v := range r { if buf.Len() \u0026gt; 0 || v != 0 { buf.WriteByte(byte(v) + \u0026#39;0\u0026#39;) } } if buf.Len() == 0 { buf.WriteByte(\u0026#39;0\u0026#39;) } return buf.String() } ","date":"2018-07-26T15:35:19+08:00","permalink":"https://www.orztu.com/leetcode/043-multiply-strings/","title":"LeetCode 43. Multiply Strings"},{"content":"Combination Sum II\nDescription Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\nEach number in candidates may only be used once in the combination.\nNote:\nAll numbers (including target) will be positive integers.\nThe solution set must not contain duplicate combinations.\nExample 1:\n1 2 3 4 5 6 7 8 Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] Example 2:\n1 2 3 4 5 6 Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [ [1,2,2], [5] ] Solution 与上一篇 Combination Sum 几乎一毛一样。只是多了一步去重操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func combinationSum2(candidates []int, target int) [][]int { sort.Ints(candidates) return doCombinationSum(candidates, target) } func doCombinationSum(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } t := target - candidates[0] if t == 0 { res = append(res, []int{candidates[0]}) } else if t \u0026gt; 0 { res = doCombinationSum(candidates[1:], t) for i, v := range res { res[i] = append([]int{candidates[0]}, v...) } } // 为了去重 for len(candidates) \u0026gt; 1 \u0026amp;\u0026amp; candidates[0] == candidates[1] { candidates = candidates[1:] } res = append(res, doCombinationSum(candidates[1:], target)...) return res } Similar Problem 1. Two Sum 15. 3Sum 18. 4Sum 39. Combination Sum ","date":"2018-07-26T10:39:33+08:00","permalink":"https://www.orztu.com/leetcode/040-combination-sum-ii/","title":"LeetCode 40. Combination Sum II"},{"content":"Combination Sum\nDescription Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\nThe same repeated number may be chosen from candidates unlimited number of times.\nNote:\nAll numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1:\n1 2 3 4 5 6 Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ] Example 2:\n1 2 3 4 5 6 7 Input: candidates = [2,3,5], target = 8, A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ] 给出加数与和数，求出所有组合。\nSolution 思路是与之前做过的查找解的题目相似：\n把target减去候选数，得到剩余target，继续查找，直到target为0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func combinationSum(candidates []int, target int) [][]int { sort.Ints(candidates) return doCombinationSum(candidates, target) } func doCombinationSum(candidates []int, target int) [][]int { res := [][]int{} if len(candidates) == 0 { return res } t := target - candidates[0] if t \u0026lt; 0 { return res } else if t == 0 { res = append(res, []int{candidates[0]}) } else if t \u0026gt; 0 { res = doCombinationSum(candidates, t) for i, v := range res { res[i] = append([]int{candidates[0]}, v...) } } res = append(res, doCombinationSum(candidates[1:], target)...) return res } Similar Problem 1. Two Sum 15. 3Sum 18. 4Sum 40. Combination Sum II ","date":"2018-07-26T10:16:53+08:00","permalink":"https://www.orztu.com/leetcode/039-combination-sum/","title":"LeetCode 39. Combination Sum"},{"content":"Valid Sudoku\nDescription Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\nEach row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid.\nThe Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n验证数独\nExample 1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 Input: [ [\u0026#34;5\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;], [\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;], [\u0026#34;.\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;], [\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;3\u0026#34;], [\u0026#34;4\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;1\u0026#34;], [\u0026#34;7\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;], [\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;], [\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;5\u0026#34;], [\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;9\u0026#34;] ] Output: true Example 2:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Input: [ [\u0026#34;8\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;], [\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;], [\u0026#34;.\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;], [\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;3\u0026#34;], [\u0026#34;4\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;1\u0026#34;], [\u0026#34;7\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;], [\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;], [\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;5\u0026#34;], [\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;9\u0026#34;] ] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8\u0026#39;s in the top left 3x3 sub-box, it is invalid. Note:\nA Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character \u0026lsquo;.\u0026rsquo;.\nThe given board size is always 9x9. 判断数独板是否有效。\n注：\n一个数组板可以是有效但是无解的。\nSolution 根据题意只需要判断数独板中给出的数字在行列和3x3格子中是否有重复即可。而不需要判断是否可以解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func isValidSudoku(board [][]byte) bool { // 用于标记第x列已使用的数字 colUsed := [9][9]bool{} // 用于标记3x3小方格已使用的数字 subBoxUsed := [3][3][9]bool{} for row := 0; row \u0026lt; 9; row++ { // 用于标记当前行已使用的数字 rowUsed := [9]bool{} for col := 0; col \u0026lt; 9; col++ { b := board[row][col] if b == \u0026#39;.\u0026#39; { continue } num := b - \u0026#39;0\u0026#39; - 1 // 检查数字是否已使用 if rowUsed[num] || colUsed[col][num] || subBoxUsed[row / 3][col / 3][num] { return false } // 标记为已使用 rowUsed[num] = true colUsed[col][num] = true subBoxUsed[row / 3][col / 3][num] = true } } return true } Similar Problem 37. Sudoku-Solver\n","date":"2018-07-26T09:22:05+08:00","permalink":"https://www.orztu.com/leetcode/036-valid-sudoku/","title":"LeetCode 36. Valid Sudoku"},{"content":"Search in Rotated Sorted Array\nDescription Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\nYou are given a target value to search. If found in the array return its index, otherwise return -1.\nYou may assume no duplicate exists in the array.\nYour algorithm\u0026rsquo;s runtime complexity must be in the order of O(log n).\nExample 1:\n1 2 Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Example 2:\n1 2 Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 假设有一个升序的数组，但是从某处出现了旋转。\n要在此数组中查找给定值，并且时间复杂度为O(log n)。\nSolution 此题为二分查找法的一个变形：\n跟二分查找法一样，先找出中间数，判断是否命中。\n如果未命中，则根据大小判断是落在左边还是右边。\n当我们找出中间数之后，需要确定哪一边是完全升序的数组。然后判断目标是否落在该区域，以决定接下来在哪边进行查找。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 递归写法 func search(nums []int, target int) int { if len(nums) == 0 { return -1 } mid := len(nums) / 2 if nums[mid] == target { return mid } search_right := func() int { r := search(nums[mid:], target) if r == -1 { return -1 } return mid + r } search_left := func() int { return search(nums[:mid], target) } // 判断左边是否有序 if nums[0] \u0026lt; nums[mid] { // 左边有序时判断是否在左边范围 if target \u0026gt;= nums[0] \u0026amp;\u0026amp; target \u0026lt;= nums[mid] { return search_left() } return search_right() } else { // 右边有序时判断是否在右边范围 if target \u0026gt;= nums[mid] \u0026amp;\u0026amp; target \u0026lt;= nums[len(nums) - 1] { return search_right() } return search_left() } } Similar Problem 81. Search in Rotated Sorted Array II ","date":"2018-07-25T14:28:45+08:00","permalink":"https://www.orztu.com/leetcode/033-search-in-rotated-sorted-array/","title":"LeetCode 33. Search in Rotated Sorted Array"},{"content":"Longest Valid Parentheses\nDescription Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.\nExample 1:\n1 2 3 Input: \u0026#34;(()\u0026#34; Output: 2 Explanation: The longest valid parentheses substring is \u0026#34;()\u0026#34; **Example 2:** ``` Input: \")()())\" Output: 4 Explanation: The longest valid parentheses substring is \"()()\" ``` 输出最长的左右括号匹配的子串长度\nSolution 逐个字符扫描并记录左右括号长度，当左右括号数量相等时，左右括号达到全匹配。\n如果只从左往右扫描，\u0026quot;((()\u0026quot;这种左括号多于右括号的会被判断为0，所以需要进行一次从右往左扫描。\n\u0026quot;())()()\u0026quot;这种中间多出右括号的情况，需要重置计数器，从后面继续扫描。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 func longestValidParentheses(s string) int { longest := 0 left, right := 0, 0 check_longest := func() { // 如果左右相等则此时左右括号匹配 if left == right { if left * 2 \u0026gt; longest { longest = left * 2 } } } // 从左往右扫描 for i := 0; i \u0026lt; len(s); i++ { if s[i] == \u0026#39;(\u0026#39; { left++ } else { right++ // 右括号多于左括号，则不满足连续匹配规则，需要重置 if right \u0026gt; left { left, right = 0, 0 continue } } check_longest() } left, right = 0, 0 // 从右往左扫描 for i := len(s) - 1; i \u0026gt;= 0; i-- { if s[i] == \u0026#39;(\u0026#39; { left++ // 左括号多于右括号，则不满足连续匹配规则 if left \u0026gt; right { left, right = 0, 0 continue } } else { right++ } check_longest() } return longest } Similar Problem 20. Valid-Parentheses\n","date":"2018-07-25T09:56:49+08:00","permalink":"https://www.orztu.com/leetcode/032-longest-valid-parentheses/","title":"LeetCode 32. Longest Valid Parentheses"},{"content":"Next Permutation\nDescription Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\nThe replacement must be in-place and use only constant extra memory.\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1\n实现字典序排列的 nextPermutation 方法，假如已经是最大排列，则输出最小排列。\n字典序排列 我们在字符串大小比较时，就已经使用了字典序:\n例如：abc \u0026lt; abcd \u0026lt; abde \u0026lt; afab\n所以字典序排列算法中有：\n最小排列：1-n，eg：1,2,3,4 最大排列：n-1，eg：4,3,2,1 next-permutation：根据当前排列，生成恰好比它大的下一个排列 通过字典序树可以更好的理解：\nSolution 参考 wikipedia 中关于字典序排列的算法描述：\nFind the largest index k such that a[k] \u0026lt; a[k + 1]. If no such index exists, the permutation is the last permutation. Find the largest index l greater than k such that a[k] \u0026lt; a[l]. Swap the value of a[k] with that of a[l]. Reverse the sequence from a[k + 1] up to and including the final element a[n]. 假设当前排列为长度为n+1的数组a，则其下一个排列的算法为:\n查找最大的索引k，满足a[k] \u0026lt; a[k + 1]。如果不存在则当前已经是最大排列。 查找最大索引l，满足l \u0026gt; k \u0026amp;\u0026amp; a[k] \u0026lt; a[l]。 交换a[k]和a[l] 将a[k + 1], a[k + 2], ..., a[n]倒序 实现代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 func nextPermutation(nums []int) { length := len(nums) if length == 1 { return } k := length - 2 for ; k \u0026gt;= 0; k-- { if nums[k] \u0026lt; nums[k+1] { break } } if k == -1 { // 当前已经是最大排列，则输出最小排列 reverse(nums) return } l := length - 1 for ; l \u0026gt; k; l-- { if nums[l] \u0026gt; nums[k] { break } } // 交换 a[k] 和 a[l] swap(nums, k, l) // 倒序 a[k]...a[n] reverse(nums[k+1:]) } // 交换两个数 func swap(nums []int, i, j int) { tmp := nums[i] nums[i] = nums[j] nums[j] = tmp } // 将slice倒序 func reverse(nums []int) { length := len(nums) for i := 0; i \u0026lt; length / 2; i++ { swap(nums, i, length - i - 1) } } Similar Problem 60. Permutation Sequence ","date":"2018-07-19T10:17:07+08:00","permalink":"https://www.orztu.com/leetcode/031-next-permutation/","title":"LeetCode 31. Next Permutation"},{"content":"数组与切片 以前粗学时并没有留意 Golang 的数组，一直以为只有切片。\n今天看《Go 语言实践》时才发现 Golang 也有数组。与切片的区别是定义时指定长度（例如长度为 4 的 int 型数组var array [4]int）。\n数组赋值时会拷贝整个数组，所以作为参数传递时也会完整拷贝，要考虑性能合理使用，必要时可以使用指针。\n以下代码便于理解数组和切片：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; func main() { // 定义数组 a1 a1 := [4]int{1, 2, 3, 4} // 数组 a2 来自 a1 的拷贝 a2 := a1 var a3 [4]int a3 = a1 // 同样会完整拷贝 // a2 修改自己的内存区域 a2[0] = 0 // 切片 s1 来自 a1，其空间仍由 a1 实现 s1 := a1[1:2] // 修改切片 s1 会影响数组 a1 s1 = append(s1, -1, -2) fmt.Println(\u0026#34;a1:\u0026#34;, a1) fmt.Println(\u0026#34;a2:\u0026#34;, a2) fmt.Println(\u0026#34;a3:\u0026#34;, a3) fmt.Println(\u0026#34;s1:\u0026#34;, s1) } 输出：\n1 2 3 4 a1: [1 2 -1 -2] a2: [0 2 3 4] a3: [1 2 3 4] s1: [2 -1 -2] Slice 保存的是长度、容量以及其底层数组的地址。\n这里 s1 来自 a1 的切片，底层数组与 a1 同内存区域，所以对 s1 的 append 导致 a1 的数值被修改。\n在使用中也要注意这种情况，合理使用。\n使用三个索引创建切片 这种格式为：slice[i:j:k]的切片方式，前两个索引与原来相同，第三索引用于表示新切片的容量。但它不是直接表示容量大小，而是表示原切片或者数组的索引位置。当它越界时会出现运行时错误。\n所以新切片的长度和容量应该这样计算：\n1 2 长度：j - i 容量：k - i 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { a1 := [4]int{1, 2, 3, 4} // s1 来自 a1 s1 := a1[1:2:3] // 修改a[1] a1[1] = 0 fmt.Println(\u0026#34;a1:\u0026#34;, a1) fmt.Println(\u0026#34;s1:\u0026#34;, s1) fmt.Println(\u0026#34;-------------\u0026#34;) // append s1 s1 = append(s1, -1) s1 = append(s1, -2) fmt.Println(\u0026#34;a1:\u0026#34;, a1) fmt.Println(\u0026#34;s1:\u0026#34;, s1) } 输出：\n1 2 3 4 5 6 7 a1: [1 0 3 4] s1: [0] // \u0026lt;-对`a[1]`的修改也影响了 s1 --- a1: [1 0 -1 4] s1: [0 -1 -2] 使用slice[i:j:k]创建切片的时候，同样没有立即创建新的底层数组，只会在append导致len \u0026gt; cap扩容时才创建新数组。\n","date":"2018-06-25T15:22:42+08:00","permalink":"https://www.orztu.com/post/golang-slice-and-array/","title":"Golang Slice and Array"},{"content":"功能 使用知名python图片处理库PIL，为图片添加文字水印。\n步骤：根据文字生成水印图片；将水印图半透明并覆盖在原图上。\n实现 1. 将文字转换成水印图片 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def gen_mark(args): # 字体宽度 length = len(args.mark) * args.size # 创建水印图片(宽度、高度) mark = Image.new(mode=\u0026#39;RGBA\u0026#39;, size=(length, args.size)) # 生成文字 draw = ImageDraw.Draw(im=mark) draw.text(xy=(0, 0), text=args.mark, # 水印文字 fill=args.color, # 文字颜色 \u0026#39;#008B8B\u0026#39; font=ImageFont.truetype(TTF_FONT, # 文字字体 size=args.size)) # font_size 文字大小 del draw # 裁剪图片边缘空白区域 bg = Image.new(mode=\u0026#39;RGBA\u0026#39;, size=mark.size) diff = ImageChops.difference(mark, bg) del bg bbox = diff.getbbox() if bbox: mark = mark.crop(bbox) # 设置水印透明度 set_opacity(mark, args.opacity) # 得到水印文字大小 print(mark.size) 此处省略... 2. 将水印图片覆盖在原图上 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def mark_im(im): \u0026#39;\u0026#39;\u0026#39; 在im图片上添加水印 im为打开的原图\u0026#39;\u0026#39;\u0026#39; # 计算斜边长度 c = int(math.sqrt(im.size[0]*im.size[0] + im.size[1]*im.size[1])) # 以斜边长度为宽高创建大图（旋转后大图才足以覆盖原图） mark2 = Image.new(mode=\u0026#39;RGBA\u0026#39;, size=(c, c)) # 在大图上生成水印文字，此处mark为上面生成的水印图片 y, idx = 0, 0 while y \u0026lt; c: # 制造x坐标错位 x = -int((mark.size[0] + args.space)*0.5*idx) idx = (idx + 1) % 2 while x \u0026lt; c: # 在该位置粘贴mark水印图片 mark2.paste(mark, (x, y)) x = x + mark.size[0] + args.space y = y + mark.size[1] + args.space # 将大图旋转一定角度 mark2 = mark2.rotate(args.angle) # 在原图上添加大图水印 if im.mode != \u0026#39;RGBA\u0026#39;: im = im.convert(\u0026#39;RGBA\u0026#39;) im.paste(mark2, # 大图 (int((im.size[0]-c)/2), int((im.size[1]-c)/2)), # 坐标 mask=mark2.split()[3]) del mark2 return im 代码 github: 2Dou/watermarker\n","date":"2018-05-10T10:54:06+08:00","image":"https://www.orztu.com/post/text-watermark/text-watermark-test_hu_45fa352fb705e903.png","permalink":"https://www.orztu.com/post/text-watermark/","title":"Python 为图片添加文字水印"},{"content":"Divide Two Integers\nDescription Divide two integers without using multiplication, division and mod operator.\nIf it is overflow, return MAX_INT.\n不使用乘法、除法、取余实现两个整数相除。\n根据除法的原理，基本思路是使用减法获得结果。将被除数变为被减数，除数变为减数。被减数循环减去减数直到被减数比减数小，中间减去的个数即为除法结果。\n考虑被除数比除数大很多的情况，为了提升效率，被减数需要指数增加。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 func abs(n int) int { if n \u0026lt; 0 { return -n } return n } func divide(dividend int, divisor int) int { if divisor == 0 { // 被除数为0!? return 0 } else if divisor == 1 { return dividend } else if divisor == -1 { // 边界检查 if dividend == math.MinInt32 { return math.MaxInt32 } return -dividend } r, n := 0, 1 a, b := abs(dividend), abs(divisor) if a \u0026lt; b { return 0 } // 指数逼近 for a \u0026gt;= b { a = a - b // 减去n个b r += n // 结果加上n b = b \u0026lt;\u0026lt; 1 // 移位替代乘法 n = n \u0026lt;\u0026lt; 1 } // 判断结果是否为负数 if (dividend \u0026gt; 0 \u0026amp;\u0026amp; divisor \u0026lt; 0) || (dividend \u0026lt; 0 \u0026amp;\u0026amp; divisor \u0026gt; 0) { r = -r } // 余数大于被除数，继续相除 if a \u0026gt;= abs(divisor) { if r \u0026lt; 0 { return r + divide(a, -abs(divisor)) } else { return r + divide(a, abs(divisor)) } } return r } ","date":"2018-03-30T16:59:00+08:00","permalink":"https://www.orztu.com/leetcode/029-divide-two-integers/","title":"LeetCode 29. Divide Two Integers"},{"content":"使用 Python + adb 实现微信跳一跳外挂\n源码地址\n使用方法 安卓手机打开USB调试\n打开USB调试方法，进入设置，找到开发者选项，打开并勾选USB调试；\n如果没有开发者选项，进入关于手机，连续点击版本号7次，即可开启开发者选项\n进入微信跳一跳并点开始游戏，运行python helper.py\n实现原理 使用adb命令截图保存到本地\n1 2 3 4 5 adb shell screencap -p | perl -pe \u0026#39;s/\\\\x0D\\\\x0A/\\\\x0A/g\u0026#39; \u0026gt; screen.png # 如果没有 perl 可以先保存再pull adb shell screencap -p /sdcard/screen.png adb pull /sdcard/screen.png . 使用python解析图片并查找棋子和落点\n根据棋子颜色，取底部左右两边特征点，以中点为棋子位置 寻找落点 有小圆点，直接通过圆点颜色RGB(245, 245, 245)找出圆点位置作为落点\n纯色平台\n从上往下查找第一个与背景色不同的点，作为平台顶点 从顶点开始向左下搜索与顶点相同颜色的点，找到平台左顶点 从顶点开始向右下搜索与顶点相同颜色的点，找到平台右顶点 以左右点中点为落点\n其他情况\n同样从上往下查找第一个与背景色不同的点，作为平台顶点 通过固定斜率0.58、棋子当前位置，计算落点（图中红线交点）\n使用adb命令模拟触摸\n1 adb shell input swipe x y x y time #其中x和y是屏幕坐标，time是触摸时间，单位ms 详解 寻找棋子 直接通过棋子特征颜色查找其“最左点”和“最右点”，计算中点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def find_cur_pos(img): \u0026#39;\u0026#39;\u0026#39; 查找棋子当前位置 通过棋子底部颜色范围，搜索棋子左右点，以中点作为棋子当前位置 \u0026#39;\u0026#39;\u0026#39; width, height = img.width, img.height local = [(width, 0), (0, 0)] def put_in(x, y): left, right = local[0], local[1] if x \u0026lt; left[0]: left = (x, y) local[0] = left if x \u0026gt;= right[0]: right = (x, y) local[1] = right for x in range(int(width * 0.1), int(width * 0.9)): for y in range(int(height * 0.52), int(height * 0.62)): pixel = img.getpixel((x, y)) r, g, b = pixel[0], pixel[1], pixel[2] if r \u0026lt; 45 and r \u0026gt; 40 and \\ g \u0026lt; 45 and g \u0026gt; 40 and \\ b \u0026lt; 75 and b \u0026gt; 70: put_in(x, y) if r \u0026lt; 60 and r \u0026gt; 50 and \\ g \u0026lt; 60 and g \u0026gt; 50 and \\ b \u0026lt; 90 and b \u0026gt; 80: put_in(x, y) left, right = local[0], local[1] if left[0] == width: return None x = int((left[0] + right[0]) / 2) y = int((left[1] + right[1]) / 2) return (x, y) 寻找小圆点 通过圆点颜色RGB(245, 245, 245)寻找落点\n以落点在左边为例：\n通过圆点颜色RGB(245, 245, 245)、斜率K、坐标x，计算斜线上的点并判断颜色\n通常先查找到A点，然后分别向右和向下查找B和C点，以BC线段中点作为落点。\n落点在右边时先搜索到的点A位置稍有不同，但算法相同\n查找点A的代码：\n1 2 3 4 5 6 7 8 9 10 11 # 查找点A for x in ite: \u0026#39;\u0026#39;\u0026#39; 通过斜率计算斜线上的位置，并判断是否和圆点颜色一样 \u0026#39;\u0026#39;\u0026#39; y = int(cur[1] - 0.58 * abs(cur[0] - x)) pixel = img.getpixel((x, y)) r, g, b = pixel[0], pixel[1], pixel[2] if r == 245 and g == 245 and b == 245: one_of_circle = (x, y) break 寻找平台中心点 首先寻找平台顶点，然后寻找左右顶点，计算平台中心点\n寻找平台顶点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 next_top, top_pixel = None, None # 顶点坐标和颜色 # 从上往下查找第一个与背景色不同的点，作为平台顶点 for y in range(int(height * 0.3), int(height * 0.52)): # 背景色，因为有渐变，所以每行重新获取背景色 bg_pixel = img.getpixel((width - 1, y)) for x in ite: pixel = img.getpixel((x, y)) # 渐变问题，允许差值 if abs(pixel[0] - bg_pixel[0]) \u0026gt; 8 \\ or abs(pixel[1] - bg_pixel[1]) \u0026gt; 8 \\ or abs(pixel[2] - bg_pixel[2]) \u0026gt; 8: next_top = (x, y) top_pixel = pixel break if next_top != None: break 搜索左右顶点\n这种方法在某些情形会出现错误，暂未处理。可以通过设定点与点之间的规则排除这些平台（距离、y差值范围等规则）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 x, y = next_top while True: while True: # 向左查找相同颜色点 if not same_color(img.getpixel((x - 1, y)), top_pixel): break x -= 1 # 向下一个像素 if not same_color(img.getpixel((x, y + 1)), top_pixel): break y += 1 if x != next_top[0] and y != next_top[1]: left = (x, y) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 x, y = next_top while True: while True: # 向右查找相同颜色点 if not same_color(img.getpixel((x + 1, y)), top_pixel): break x += 1 # 向下查找相同颜色点 if not same_color(img.getpixel((x, y + 1)), top_pixel): break y += 1 if x != next_top[0] and y != next_top[1]: right = (x, y) 其他情况计算落点 如果当前棋子位置有偏差，这种方式结果会出现偏差\n1 2 3 # x, y 为平台顶点坐标 k = 0.58 # 斜率 y = cur[1] - k * float(x - cur[0]) 模拟触摸 通过当前位置和落点位置计算出距离distance，然后触摸时长T = distance * P\n不同分辨率下，系数P不同，需要查找\n1600x2560机型推荐0.92\n1440x2560机型推荐1.039\n1080x1920机型推荐1.392\n720x1280机型推荐2.078\n参考 思路来自WechatJumpHelper\n","date":"2018-01-08T10:00:41+08:00","permalink":"https://www.orztu.com/post/wechat-jump/","title":"Python 实现微信跳一跳外挂"},{"content":"Reverse Nodes in k-Group\nDescription Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\nYou may not alter the values in the nodes, only nodes itself may be changed.\nOnly constant memory is allowed.\nFor example,\nGiven this linked list: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5\nFor k = 2, you should return: 2-\u0026gt;1-\u0026gt;4-\u0026gt;3-\u0026gt;5\nFor k = 3, you should return: 3-\u0026gt;2-\u0026gt;1-\u0026gt;4-\u0026gt;5\n将链表按长度k分组并反转\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 func reverseKGroup(head *ListNode, k int) *ListNode { if head == nil || k \u0026lt;= 1 { return head } var newHead, lastGroupTail *ListNode nextGroupHead := head for nextGroupHead != nil { right := nextGroupHead // search the first node of reversed-group for n := 0; n \u0026lt; k-1 \u0026amp;\u0026amp; right != nil; n++ { right = right.Next } if right == nil { // no more group, so break break } if newHead == nil { // first group, set newHead newHead = right } else { // else, link last group and this group lastGroupTail.Next = right } // saving infomation to search next group lastGroupTail, nextGroupHead = nextGroupHead, right.Next // reversing this group left, right := lastGroupTail, nextGroupHead for left != nextGroupHead { left, left.Next, right = left.Next, right, left } } if newHead == nil { return head } return newHead } ","date":"2017-12-29T14:23:13+08:00","permalink":"https://www.orztu.com/leetcode/025-reverse-nodes-in-k-group/","title":"LeetCode 25. Reverse Nodes in k-Group"},{"content":"Merge k Sorted Lists\nDescription Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n将k个有序链表合并为一个链表\nSolution 前面刚做了两条链表的合并Merge Two Sorted Lists。\n既然两个的合并都做了，k个还会难吗？\n显然，将k个链表两两合一即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 func mergeKLists(lists []*ListNode) *ListNode { if len(lists) == 0 { return nil } res := lists[0] for i := 1; i \u0026lt; len(lists); i++ { res = mergeTwoLists(res, lists[i]) } return res } Similar Problem 21. Merge Two Sorted Lists ","date":"2017-11-24T14:55:46+08:00","permalink":"https://www.orztu.com/leetcode/023-merge-k-sorted-lists/","title":"LeetCode 23. Merge K Sorted Lists"},{"content":"Generate Parentheses\nDescription Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nFor example, given n = 3, a solution set is:\n1 2 3 4 5 6 7 [ \u0026#34;((()))\u0026#34;, \u0026#34;(()())\u0026#34;, \u0026#34;(())()\u0026#34;, \u0026#34;()(())\u0026#34;, \u0026#34;()()()\u0026#34; ] 给出n组括号，生成所有正确的匹配组合\nSolution 本题不贴代码。\n思路是生成过程中，保持右括号数量不超过左括号数量即可。\n","date":"2017-11-22T11:32:00+08:00","permalink":"https://www.orztu.com/leetcode/022-generate-parentheses/","title":"LeetCode 22. Generate Parentheses"},{"content":"Merge Two Sorted Lists\nDescription Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\n将两个有序链表合二为一\nSolution 逐次比较l1、l2，将较小的那个结点添加到新链表尾部，并指向下一个结点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } else if l2 == nil { return l1 } var head, tail *ListNode // 将首次判断放在循环外，可以减少判断次数，提高效率 if l1.Val \u0026lt; l2.Val { head = l1 l1 = l1.Next } else { head = l2 l2 = l2.Next } tail = head for { if l1 == nil { tail.Next = l2 break } else if l2 == nil { tail.Next = l1 break } else if l1.Val \u0026lt; l2.Val { tail.Next = l1 tail = l1 l1 = l1.Next } else { tail.Next = l2 tail = l2 l2 = l2.Next } } return head } Similar Problem 88. Merge Sorted Array ","date":"2017-11-22T09:15:44+08:00","permalink":"https://www.orztu.com/leetcode/021-merge-two-sorted-lists/","title":"LeetCode 21. Merge Two Sorted Lists"},{"content":"Valid Parentheses\nDescription Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nThe brackets must close in the correct order, \u0026quot;()\u0026quot; and \u0026quot;()[]{}\u0026quot; are all valid but \u0026quot;(]\u0026quot; and \u0026quot;([)]\u0026quot; are not.\n给出包含三种括号的字符串，验证括号是否左右匹配\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 func isValid(s string) bool { var c byte stack := make([]byte, 0) m := map[byte]byte{ \u0026#39;)\u0026#39;: \u0026#39;(\u0026#39;, \u0026#39;]\u0026#39;: \u0026#39;[\u0026#39;, \u0026#39;}\u0026#39;: \u0026#39;{\u0026#39;, } for i := 0; i \u0026lt; len(s); i++ { c = s[i] if c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39; { stack = append(stack, c) } else { if v, ok := m[c]; ok { if !pop(v, \u0026amp;stack) { return false } } else { return false } } } return len(stack) == 0 } func pop(c byte, stack *[]byte) bool { l := len(*stack) if l \u0026lt; 1 { return false } var poped byte *stack, poped = (*stack)[:l-1], (*stack)[l-1] return poped == c } Similar Problem 10. Regular Expression Matching\n","date":"2017-10-30T19:25:35+08:00","permalink":"https://www.orztu.com/leetcode/020-valid-parentheses/","title":"LeetCode 20. Valid Parentheses"},{"content":"Remove Nth Node From End of List\nDescription Given a linked list, remove the nth node from the end of list and return its head.\n1 2 3 For example, Given linked list: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-\u0026gt;2-\u0026gt;3-\u0026gt;5. Note:\nGiven n will always be valid.\nTry to do this in one pass.\n从链表中删除倒数第n个结点（n必定有效）\nSolution 1. 使用循环 定义 p1 = p2 = head\n先让p1前进n个结点。如果此时n为空，说明要删除的是head结点，直接返回head.Next，否则进行后面步骤\n此时p1与p2相差n个结点。让p1、p2同时前进，知道p1指向尾结点，此时p2指向倒数第n+1个结点\n删除p2.Next(即倒数第n个结点)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { p1 := head // point the next Nth node for i := 0; i \u0026lt; n; i++ { p1 = p1.Next } if p1 == nil { // It\u0026#39;s removing the first node from begin return head.Next } p2 := head // p2 is now n step behind p1 // let p1 point to the 1st node from end // so p2 is pointing to the (n+1)th node from end for p1.Next != nil { p1 = p1.Next p2 = p2.Next } // now remove the Nth node from begin p2.Next = p2.Next.Next return head } 2. 使用递归 使用递归一直向后查找，直到最后一个结点(head.Next == nil)。此时递归结束，开始返回：当前结点指针和0。相当于将最后一个结点标记为0\n判断递归返回的标记是否等于n，是则表示p为倒是第(n+1)个结点（因为标记从0开始），也是我们需要查找的结点。否则将标记加1，返回head（即p的父节点）。\n递归完全返回后，函数removeNthFromEnd里的 index 如果为0，则表示parent指向第倒数n+1；不为0则没找到，原因是要删除结点的是正向第一个。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { parent, index := search(head, n) if index != n { // It must be removing the first node from begin return head.Next } // remove the child node parent.Next = parent.Next.Next return head } func search(head *ListNode, n int) (*ListNode, int) { if head.Next == nil { // mark last node\u0026#39;s index as 0 return head, 0 } p, index := search(head.Next, n) if index == n { // so index n is the (n+1)th node from the end // it\u0026#39;s the parent of the node which we want to remove return p, index } return head, index + 1 } ","date":"2017-10-19T21:03:59+08:00","permalink":"https://www.orztu.com/leetcode/019-remove-nth-node-from-end-of-list/","title":"LeetCode 19. Remove Nth Node From End of List"},{"content":" 系统安装 系统: raspbian 工具（二选一）：\nEtcher Win32DiskImager（windows only） 将SD卡格式化成exFat格式 使用Etcher或者Win32DiskImager将下载的raspbian系统镜像(img文件)写入SD卡 写入完成之后就相当于系统安装完成了。这时候SD卡被分成两个区，有一个区是在windows下无法识别，不用理会。\n这时候如果直接将SD卡插入树莓派，会发现“无法启动”。显示屏没信号，在路由器里找到树莓派的IP也无法用ssh登录。\n我安装的时候就是踩到这个坑。以为安装失败，反复装了好几次，就差把SD卡写穿了。\n实际系统安装已经成功了。只需要在电脑上打开SD卡，找到config.txt文件里#hdmi_safe=1这一行，将前面的#号去掉；\n再新建一个文件命名为ssh（不能有扩展名）。\n再次把SD卡装进树莓派启动，显示屏就可以正常显示了，ssh也能登录了。\n基本配置 1. 静态IP/固定IP 打开/etc/dhcpcd.conf文件，找到网口（一般为eth0）\n指定IP:\n1 2 3 interface eth0 static ip_address=192.168.1.20/24 static routers=192.168.1.1 2. iptables 刚开始配置iptables的时候，以为创建好规则后，使用iptables-save就可以保存了，结果重启后又失效。\n为了持久化规则，可以使用iptables-persistent。\n运行apt-get安装：sudo apt-get install iptables-persistent安装。\n然后在/etc/iptables/rules.v4里面编辑规则\n3. 修改主机名 需要修改两个文件：\n替换/etc/hostname里的主机名 替换/etc/hosts里的主机名 4. 修改用户名 为了修改默认用户名pi，需要临时使用root帐号登录。\n启用root帐号\n1 2 3 4 # 为root帐号设置密码 sudo passwd root # 启用root帐号 sudo passwd --unlock root ssh默认是禁止root登录的，所以还需要修改ssh配置：编辑文件/etc/ssh/sshd_config，添加一行PermitRootLogin yes即可。\n1 2 # 重启 sudo reboot 重启系统并登录root后修改pi账户\n1 2 3 4 5 6 7 8 # 修改用户名为NEWNAME usermod -l NEWNAME pi # 修改用户group groupmod -n NEWNAME pi # 修改账户主目录 mv /home/pi /home/NEWNAME # 设置主目录 usermod -d /home/NEWNAME NEWNAME 重启登录NEWNAME\n登录后检查新用户是否能正常使用sudo，如果不能则再次使用root登录，往/etc/sudoers中添加一行：NEWNAME ALL=(ALL) ALL。\n新账户正常后禁用root\n1 2 # 禁用root sudo passwd -l root 别忘了还有ssh配置文件也要修改。\n","date":"2017-10-18T16:44:36+08:00","permalink":"https://www.orztu.com/post/raspbian-install-and-configure/","title":"树莓派 Raspbian系统安装与基本配置"},{"content":"4Sum\nDescription Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\nNote: The solution set must not contain duplicate quadruplets.\n1 2 3 4 5 6 7 8 For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 在给定数组中找出“和为 target 的四个数”的所有解。\n需要避免重复的解。\n这次的答案适用N个数的和；好理解。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 func fourSum(nums []int, target int) [][]int { sort.Ints(nums) return sum(nums, target, 4) } func sum(nums []int, target int, n int) [][]int { if len(nums) \u0026lt; n || // not enough numbers sumOfSlice(nums[len(nums)-n:]) \u0026lt; target || // max-sum still smaller than target sumOfSlice(nums[:n]) \u0026gt; target { // min-sum still bigger than target // no answer return [][]int{} } res := make([][]int, 0) for i := 0; i \u0026lt; len(nums); i++{ num := nums[i] if n == 1 \u0026amp;\u0026amp; num == target { return [][]int{ []int{num}, } } else if n \u0026gt; 1 { // let\u0026#39;s suppose num is one of the n numbers // so the other n-1 numbers\u0026#39; sum is target-num // then search the rest numbers for _, r := range sum(nums[i+1:], target-num, n-1) { res = append(res, append(r, num)) } // skip the same numbers for j := i + 1; j \u0026lt; len(nums) \u0026amp;\u0026amp; nums[j] == num; j++ { i++ } } } return res } // get sum of slice func sumOfSlice(nums []int) int { if len(nums) == 1 { return nums[0] } return nums[0] + sumOfSlice(nums[1:]) } Similar Problem 1. Two Sum 15. 3Sum 39. Combination Sum 40. Combination Sum II ","date":"2017-10-17T16:27:33+08:00","permalink":"https://www.orztu.com/leetcode/018-4sum/","title":"LeetCode 18. 4Sum"},{"content":"Letter Combinations of a Phone Number\nDescription Given a digit string, return all possible letter combinations that the number could represent.\nA mapping of digit to letters (just like on the telephone buttons) is given below.\n1 2 Input: Digit string \u0026#34;23\u0026#34; Output: [\u0026#34;ad\u0026#34;, \u0026#34;ae\u0026#34;, \u0026#34;af\u0026#34;, \u0026#34;bd\u0026#34;, \u0026#34;be\u0026#34;, \u0026#34;bf\u0026#34;, \u0026#34;cd\u0026#34;, \u0026#34;ce\u0026#34;, \u0026#34;cf\u0026#34;]. 输入九宫格输入法数字，输出对应的所有字母组合\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func letterCombinations(digits string) []string { if len(digits) \u0026lt; 1 { return []string{} } if len(digits) == 1 { switch digits { case \u0026#34;2\u0026#34;: return []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} case \u0026#34;3\u0026#34;: return []string{\u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;} case \u0026#34;4\u0026#34;: return []string{\u0026#34;g\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;i\u0026#34;} case \u0026#34;5\u0026#34;: return []string{\u0026#34;j\u0026#34;, \u0026#34;k\u0026#34;, \u0026#34;l\u0026#34;} case \u0026#34;6\u0026#34;: return []string{\u0026#34;m\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;o\u0026#34;} case \u0026#34;7\u0026#34;: return []string{\u0026#34;q\u0026#34;, \u0026#34;p\u0026#34;, \u0026#34;r\u0026#34;, \u0026#34;s\u0026#34;} case \u0026#34;8\u0026#34;: return []string{\u0026#34;t\u0026#34;, \u0026#34;u\u0026#34;, \u0026#34;v\u0026#34;} case \u0026#34;9\u0026#34;: return []string{\u0026#34;w\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;} case \u0026#34;0\u0026#34;: return []string{\u0026#34; \u0026#34;} default: return []string{\u0026#34;\u0026#34;} } } r := make([]string, 0) for _, front := range letterCombinations(digits[:1]) { for _, back := range letterCombinations(digits[1:]) { r = append(r, front+back) } } return r } ","date":"2017-10-17T14:39:40+08:00","permalink":"https://www.orztu.com/leetcode/017-letter-combinations-of-a-phone-number/","title":"LeetCode 17. Letter Combinations of a Phone Number"},{"content":"最近V2上很多卖GV号码的，心想这玩意也能值钱。所以想着自己试试动手申请一个。\n首先参照这篇\n“免费申请Google Voice美国电话号码”申请号码。\n到了这一步：提示“There was an error with your request. Please try again.”\n听说在这里反复提交直到申请成功即可。找了网上的自动提交方法（复制出来CURL提交），发现不好使，curl一直没响应。\n但是网页上确实可以反复点击提交的。于是改用自动点击的方式，一夜醒来发现已经申请成功。\n使用Chrome浏览器，右键-\u0026gt;审查元素。\n然后切换到Console中粘贴以下代码，回车，实现自动点击。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function triggerMouseEvent (node, eventType) { var clickEvent = document.createEvent (\u0026#39;MouseEvents\u0026#39;); clickEvent.initEvent (eventType, true, true); node.dispatchEvent (clickEvent); } function clickTheBtn(){ // 查找按钮 var btn = document.getElementsByClassName(\u0026#34;continueButton\u0026#34;)[0]; // 模拟点击 triggerMouseEvent(btn, \u0026#34;mouseover\u0026#34;); triggerMouseEvent(btn, \u0026#34;mousedown\u0026#34;); triggerMouseEvent(btn, \u0026#34;mouseup\u0026#34;); triggerMouseEvent(btn, \u0026#34;click\u0026#34;); } // 每2.5秒调用一次clickTheBtn setInterval(clickTheBtn, 2500); ","date":"2017-08-09T08:44:10+08:00","permalink":"https://www.orztu.com/post/gvoice-number/","title":"自动点击 - 申请Google Voice号码"},{"content":"3Sum\nDescription Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\nNote: The solution set must not contain duplicate triplets.\n1 2 3 4 5 6 7 For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 在给定数组中找出“和为0的三个数”的所有解。\n需要避免重复的解（相同数字组合的解为重复）。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 func threeSum(nums []int) (res [][]int) { if len(nums) \u0026lt; 3 { return } // 从小到大排序 sort.Ints(nums) for i := 0; i \u0026lt; len(nums)-2; i++ { left, right := i+1, len(nums)-1 num0 := nums[i] num1 := nums[left] num2 := nums[right] // 所有数同符号则不需要继续 if (num0 \u0026gt; 0 \u0026amp;\u0026amp; num1 \u0026gt; 0) || (num0 \u0026lt; 0 \u0026amp;\u0026amp; num2 \u0026lt; 0) { break } for left \u0026lt; right { // 求和 sum := num0 + num1 + num2 if sum == 0 { // 记录满足条件的解 res = append(res, []int{num0, num1, num2}) // 跳过相同的数字避免重复解 for left \u0026lt; right \u0026amp;\u0026amp; num1 == nums[left] { left++ } for right \u0026lt; left \u0026amp;\u0026amp; num2 == nums[right] { right-- } } else if sum \u0026lt; 0 { // 和为负数则增加num1 left++ } else { // 和为正数则减小num2 right-- } num1 = nums[left] num2 = nums[right] } // 跳过相同的num0避免重复解 for i \u0026lt; len(nums)-2 \u0026amp;\u0026amp; num0 == nums[i+1] { i++ } } return res } Similar Problem 1. Two Sum 18. 4Sum 39. Combination Sum 40. Combination Sum II ","date":"2017-07-28T08:54:12+08:00","permalink":"https://www.orztu.com/leetcode/015-3sum/","title":"LeetCode 15. 3Sum"},{"content":"Roman to Integer\nDescription Given a roman numeral, convert it to an integer.\nInput is guaranteed to be within the range from 1 to 3999.\n将罗马数字转换成整型。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func romanToInt(s string) int { num := map[uint8]int{ \u0026#39;M\u0026#39;: 1000, \u0026#39;D\u0026#39;: 500, \u0026#39;C\u0026#39;: 100, \u0026#39;L\u0026#39;: 50, \u0026#39;X\u0026#39;: 10, \u0026#39;V\u0026#39;: 5, \u0026#39;I\u0026#39;: 1, } length := len(s) if length == 0 { return 0 } res := num[s[length-1]] for i := length - 2; i \u0026gt;= 0; i-- { n := num[s[i]] if n \u0026lt; num[s[i+1]] { res -= n } else { res += n } } return res } Similar Problem 12. Integer to Roman\n","date":"2017-07-07T14:43:41+08:00","permalink":"https://www.orztu.com/leetcode/013-roman-to-integer/","title":"LeetCode 13. Roman to Integer"},{"content":"Integer to Roman\nDescription Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\n将整型转换成罗马数字形式:\nSymbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 Solution 因为限定了范围，所以千位数也用了Slice\n1 2 3 4 5 6 7 8 func intToRoman(num int) string { M := []string{\u0026#34;\u0026#34;, \u0026#34;M\u0026#34;, \u0026#34;MM\u0026#34;, \u0026#34;MMM\u0026#34;} C := []string{\u0026#34;\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;CC\u0026#34;, \u0026#34;CCC\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;DC\u0026#34;, \u0026#34;DCC\u0026#34;, \u0026#34;DCCC\u0026#34;, \u0026#34;CM\u0026#34;} X := []string{\u0026#34;\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;XX\u0026#34;, \u0026#34;XXX\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;LX\u0026#34;, \u0026#34;LXX\u0026#34;, \u0026#34;LXXX\u0026#34;, \u0026#34;XC\u0026#34;} I := []string{\u0026#34;\u0026#34;, \u0026#34;I\u0026#34;, \u0026#34;II\u0026#34;, \u0026#34;III\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;VI\u0026#34;, \u0026#34;VII\u0026#34;, \u0026#34;VIII\u0026#34;, \u0026#34;IX\u0026#34;} return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10] } Similar Problem 13. Integer to Roman\n","date":"2017-07-07T09:18:49+08:00","permalink":"https://www.orztu.com/leetcode/012-integer-to-roman/","title":"LeetCode 12. Integer to Roman"},{"content":"Container With Most Water\nDescription Given n non-negative integers a1, a2, \u0026hellip;, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\nNote: You may not slant the container and n is at least 2.\n给出n个点，它们与X轴有n条垂线，每两条垂线与X轴形成的U型容器，找出最大“容积”(面积）\nSolution 从两边往中间逼近。每次循环收紧矮的一边。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func maxArea(height []int) int { area := 0 left, right := 0, len(height)-1 for left \u0026lt; right { width := right - left h := 0 if height[right] \u0026gt; height[left] { h = height[left] left++ } else { h = height[right] right-- } a := width * h if a \u0026gt; area { area = a } } return area } func min(a, b int) int { if a \u0026gt; b { return b } return a } Similar Problem 42. Trapping Rain Water\n","date":"2017-07-06T14:09:43+08:00","permalink":"https://www.orztu.com/leetcode/011-container-with-most-water/","title":"LeetCode 11. Container With Most Water"},{"content":"\n","date":"2017-05-31T17:54:35+08:00","permalink":"https://www.orztu.com/post/tianlongbabu/","title":"天龙八部"},{"content":"N-Queens\nDescription The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle.\nEach solution contains a distinct board configuration of the n-queens\u0026rsquo; placement, where 'Q' and '.' both indicate a queen and an empty space respectively.\nFor example,\nThere exist two distinct solutions to the 4-queens puzzle:\n[\n[\u0026quot;.Q..\u0026quot;, // Solution 1\n\u0026ldquo;\u0026hellip;Q\u0026rdquo;,\n\u0026ldquo;Q\u0026hellip;\u0026rdquo;,\n\u0026ldquo;..Q.\u0026rdquo;],\n[\u0026quot;..Q.\u0026quot;, // Solution 2\n\u0026ldquo;Q\u0026hellip;\u0026rdquo;,\n\u0026ldquo;\u0026hellip;Q\u0026rdquo;,\n\u0026ldquo;.Q..\u0026rdquo;]\n]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 这是我第一次做八皇后问题，之前只是听说这么一个名字。 思路与之前[Sudoku-Solver](http://www.orztu.com/leetcode/Sudoku-Solver/)相同， 使用递归遍历每一行所有位置，判断该位置是否合法，不合法返回，合法则进入下一行。 好像大家给这种方法取了一个很洋气的名字叫*回溯* \u0026lt;small\u0026gt;*在国际象棋中，皇后可以攻击直线和斜线上的目标*\u0026lt;/samll\u0026gt; ## Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 func solveNQueens(n int) [][]string { answer := make([][]string, 0) board := make([]int, n) solve(\u0026amp;answer, board, n, 0) return answer } // put a queen on board at line l func solve(answer *[][]string, board []int, n, l int) { if n == l { *answer = append(*answer, convertBoard(board, n)) return } for i := 0; i \u0026lt; n; i++ { if !canBeAttack(board, n, l, i) { // mark the queen\u0026#39;s postion board[l] = i solve(answer, board, n, l+1) } } } // 判断会否被其他皇后攻击 func canBeAttack(board []int, n, x, y int) bool { for row := 0; row \u0026lt; x; row++ { col := board[row] if col == y || abs(row-x) == abs(col-y) { return true } } return false } // 转换成返回格式 func convertBoard(board []int, n int) []string { ans := make([]string, n) for i := 0; i \u0026lt; n; i++ { line := []byte(strings.Repeat(\u0026#34;.\u0026#34;, n)) line[board[i]] = \u0026#39;Q\u0026#39; ans[i] = string(line) } return ans } func abs(x int) int { if x \u0026lt; 0 { return -x } return x } ","date":"2017-05-04T16:23:01+08:00","permalink":"https://www.orztu.com/leetcode/051-n-queens/","title":"LeetCode 51. N-Queens"},{"content":"Trapping Rain Water\nDescription Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how \u0026gt;much water it is able to trap after raining.\nFor example,\nGiven [0,1,0,2,1,0,1,3,2,1,2,1], return 6.\nThe above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!\nSolution 每个点容量决定于左右两边高度\n先从左往右，扫描出每个点左边最高的围栏\n再从右往左，扫描出每个点右边最高的围栏\n在围栏比当前点高的情况下， 这个点的容量为围栏高度减底部高度: min(left_height, right_height) - bottom\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 func trap(height []int) int { var record int var result int length := len(height) if length \u0026lt; 3 { return 0 } leftHeight := make([]int, length) record = height[0] // record the max height of left positions // scan left height for each position for i := 0; i \u0026lt; length-1; i++ { leftHeight[i] = record n := height[i] if n \u0026gt; record { record = n } } record = height[length-1] // record the max height of right positions for i := length - 2; i \u0026gt;= 0; i-- { h := min(record, leftHeight[i]) n := height[i] if h \u0026gt; n { // have some water result += (h - n) } if n \u0026gt; record { record = n } } return result } func min(a, b int) int { if a \u0026lt; b { return a } return b } Similar Problem 11. Container With Most Water\n","date":"2017-04-28T10:01:32+08:00","permalink":"https://www.orztu.com/leetcode/042-trapping-rain-water/","title":"LeetCode 42. Trapping Rain Water"},{"content":"Sudoku Solver\nDescription Write a program to solve a Sudoku puzzle by filling the empty cells.\nEmpty cells are indicated by the character \u0026lsquo;.\u0026rsquo;.\nYou may assume that there will be only one unique solution.\nSolution 还是编程思维不行，在编程时按照解题思路在走。\n我的答案：\n查找空格，找出该位置可能的数字组合，填入，递归进入下一个空格。\n这样虽然能解出答案。但是在查找可能的数字上耗费时间较多。\n后面的Pretty Solution：\n找到空格后，直接把依次把1-9填入，验证是否重复。反而耗时更少，代码也更简洁。\nMy solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 func solveSudoku(board [][]byte) { setNumber(\u0026amp;board, 0) } func setNumber(board *[][]byte, index int) bool { row := int(index / 9) col := index % 9 if index \u0026gt;= 81 { return true } canbe := getPossibleNumbers(*board, row, col) if len(canbe) == 0 { return false } reset := (*board)[row][col] ok := true for _, num := range canbe { (*board)[row][col] = num ok = setNumber(board, index + 1) if ok { break } } if !ok { (*board)[row][col] = reset } return ok } func getPossibleNumbers(board [][]byte, i, j int) []byte { num := board[i][j] if num != \u0026#39;.\u0026#39; { // skip this position return []byte{num} } canbe := map[byte]struct{}{ \u0026#39;1\u0026#39;: struct{}{}, \u0026#39;2\u0026#39;: struct{}{}, \u0026#39;3\u0026#39;: struct{}{}, \u0026#39;4\u0026#39;: struct{}{}, \u0026#39;5\u0026#39;: struct{}{}, \u0026#39;6\u0026#39;: struct{}{}, \u0026#39;7\u0026#39;: struct{}{}, \u0026#39;8\u0026#39;: struct{}{}, \u0026#39;9\u0026#39;: struct{}{}, } // check row-i, remove number from \u0026#39;canbe\u0026#39; which have been set to other postion for col := 0; col \u0026lt; 9; col++ { if col == j { continue } if removeFromPossibleNumber(\u0026amp;canbe, board[i][col]) == 0 { return []byte{} } } // check col-j, remove number from \u0026#39;canbe\u0026#39; which have been set to other postion for row := 0; row \u0026lt; 9; row++ { if row == i { continue } if removeFromPossibleNumber(\u0026amp;canbe, board[row][j]) == 0 { return []byte{} } } // check the little sudoku block left := 3 * int(i / 3) top := 3 * int(j / 3) for l := 0; l \u0026lt; 3; l++ { for t := 0; t \u0026lt; 3; t++ { index_i := left + l index_j := top + t if index_i == i \u0026amp;\u0026amp; index_j == j { continue } if removeFromPossibleNumber(\u0026amp;canbe, board[index_i][index_j]) == 0 { return []byte{} } } } var n byte var result []byte for n = \u0026#39;1\u0026#39;; n \u0026lt;= \u0026#39;9\u0026#39;; n++ { if _, ok := canbe[n]; ok { result = append(result, n) } } return result } func removeFromPossibleNumber(canbe *map[byte]struct{}, key byte) int { if _, ok := (*canbe)[key]; ok { delete(*canbe, key) } return len(*canbe) } Pretty solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 func solveSudoku(board [][]byte) { setNumber(\u0026amp;board, 0) } func setNumber(board *[][]byte, index int) bool { row := int(index / 9) col := index % 9 if index \u0026gt;= 81 { return true } if (*board)[row][col] == \u0026#39;.\u0026#39; { var c byte for c = \u0026#39;1\u0026#39;; c \u0026lt;= \u0026#39;9\u0026#39;; c++ { (*board)[row][col] = c if valid(board, row, col) \u0026amp;\u0026amp; setNumber(board, index + 1) { return true } (*board)[row][col] = \u0026#39;.\u0026#39; } return false } else { return setNumber(board, index + 1) } } func valid(board *[][]byte, row, col int) bool { num := (*board)[row][col] // check row for i := 0; i \u0026lt; 9; i++ { if i == row { continue } if (*board)[i][col] == num { return false } } // check col for j := 0; j \u0026lt; 9; j++ { if j == col { continue } if (*board)[row][j] == num { return false } } // check the little sudoku block left := 3 * int(row / 3) top := 3 * int(col / 3) for i := left; i \u0026lt; left + 3; i++ { for j := top; j \u0026lt; top + 3; j++ { if i == row \u0026amp;\u0026amp; j == col { continue } if (*board)[i][j] == num { return false } } } return true } Similar Problem 36. Valid-Sudoku\n","date":"2017-04-22T11:35:12+08:00","permalink":"https://www.orztu.com/leetcode/037-sudoku-solver/","title":"LeetCode 37. Sudoku Solver"},{"content":"Regular Expression Matching\nDescription Implement regular expression matching with support for \u0026lsquo;.\u0026rsquo; and \u0026lsquo;*\u0026rsquo;.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026#39;.\u0026#39; Matches any single character. \u0026#39;*\u0026#39; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). The function prototype should be: bool isMatch(const char *s, const char *p) Some examples: isMatch(\u0026#34;aa\u0026#34;,\u0026#34;a\u0026#34;) → false isMatch(\u0026#34;aa\u0026#34;,\u0026#34;aa\u0026#34;) → true isMatch(\u0026#34;aaa\u0026#34;,\u0026#34;aa\u0026#34;) → false isMatch(\u0026#34;aa\u0026#34;, \u0026#34;a*\u0026#34;) → true isMatch(\u0026#34;aa\u0026#34;, \u0026#34;.*\u0026#34;) → true isMatch(\u0026#34;ab\u0026#34;, \u0026#34;.*\u0026#34;) → true isMatch(\u0026#34;aab\u0026#34;, \u0026#34;c*a*b\u0026#34;) → true 简单的字符匹配\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 func isMatch(s string, p string) bool { if len(s) == 0 \u0026amp;\u0026amp; len(p) == 0 { return true } else if len(p) == 0 { // p is empty but s return false } matchChar := p[0] if len(p) \u0026gt; 1 \u0026amp;\u0026amp; p[1] == \u0026#39;*\u0026#39; { // match any numbers of char(s) // eat two char of p p = p[2:] for len(s) \u0026gt; 0{ if s[0] == matchChar || matchChar == \u0026#39;.\u0026#39; { // try not to eat char of s if isMatch(s, p) { return true } // let\u0026#39;s eat one char of s and try again s = s[1:] } else { break } } } else { // match one char // eat one char of p p = p[1:] // does it match? if len(s) == 0 || (s[0] != matchChar \u0026amp;\u0026amp; matchChar != \u0026#39;.\u0026#39;) { return false } // eat one char of s s = s[1:] } return isMatch(s, p) } Similar Problem 20. Valid Parentheses\n","date":"2017-03-24T15:00:47+08:00","permalink":"https://www.orztu.com/leetcode/010-regular-expression-matching/","title":"LeetCode 10. Regular Expression Matching"},{"content":"Palindrome Number\nDescription Determine whether an integer is a palindrome. Do this without extra space.\n在不使用额外空间的条件下判断一个整型是否为回文\n我认为这是一个伪命题(wtf? without extra space?)\nSolution Pretty solution 1 2 3 4 5 6 7 8 9 10 11 12 func isPalindrome(x int) bool { if x \u0026lt; 0 || (x != 0 \u0026amp;\u0026amp; x%10 == 0) { return false } sum := 0 for x \u0026gt; sum { sum = sum * 10 + x % 10 x = x / 10 } return (x == sum) || (x == sum / 10) } My solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func isPalindrome(x int) bool { if x \u0026lt; 0 { return false } if x \u0026lt; 10 { return true } // get len(string(x)) - 1 l := 0 for i := x; i \u0026gt;= 10; i /= 10 { l++ } mod := 1 for i := 0; i \u0026lt; l; i++ { mod *= 10 } lnum, rnum := x, x for i := 0; i \u0026lt; (l + 1) / 2; i++ { fmt.Println(lnum, rnum) l := lnum / mod r := rnum - (rnum / 10 * 10) lnum = lnum - (l * mod) mod /= 10 rnum /= 10 fmt.Println(l, r) if l != r { return false } } return true } ","date":"2017-03-24T15:00:46+08:00","permalink":"https://www.orztu.com/leetcode/009-palindrome-number/","title":"LeetCode 9. Palindrome Number"},{"content":"String to Integer (atoi)\nDescription Implement atoi to convert a string to an integer.\nHint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the \u0026gt; possible input cases.\nNotes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the \u0026gt; input requirements up front.\n实现atoi功能\n需要注意边界检查\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func myAtoi(str string) int { str = strings.TrimLeft(str, \u0026#34; \u0026#34;) if len(str) == 0 { return 0 } r := 0 sign := 1 if str[0] == \u0026#39;-\u0026#39; { sign = -1 str = str[1:] } else if str[0] == \u0026#39;+\u0026#39; { str = str[1:] } for i := 0; i \u0026lt; len(str); i++ { c := str[i] if c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39; { r = r * 10 + (int(c - \u0026#39;0\u0026#39;) * sign) if r \u0026lt;= math.MinInt32 { return math.MinInt32 } else if r \u0026gt;= math.MaxInt32 { return math.MaxInt32 } } else { break } } return r } ","date":"2017-03-22T09:05:12+08:00","permalink":"https://www.orztu.com/leetcode/008-string-to-integer-atoi/","title":"LeetCode 8. String to Integer (atoi)"},{"content":"Reverse Integer\nDescription Reverse digits of an integer.\nExample1: x = 123, return 321\nExample2: x = -123, return -321\nThe input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows.\n将输入的十进制数倒序输出\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func reverse(x int) int { r := 0 for x != 0 { r *= 10 r += x % 10 x /= 10 } if -math.MaxInt32 \u0026lt; r \u0026amp;\u0026amp; r \u0026lt; math.MaxInt32 { return r } return 0 } ","date":"2017-03-21T16:04:44+08:00","permalink":"https://www.orztu.com/leetcode/007-reverse-integer/","title":"LeetCode 7. Reverse Integer"},{"content":"ZigZag Conversion\nDescription The string \u0026quot;PAYPALISHIRING\u0026quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this \u0026gt; pattern in a fixed font for better legibility)\n1 2 3 P A H N A P L S I I G Y I R And then read line by line: \u0026quot;PAHNAPLSIIGYIR\u0026quot;\nWrite the code that will take a string and make this conversion given a number of rows:\n1 string convert(string text, int nRows); convert(\u0026quot;PAYPALISHIRING\u0026quot;, 3) should return \u0026quot;PAHNAPLSIIGYIR\u0026quot;.\n输入之字字符串和之字的行数，要求按行输出字符串。\n\u0026quot;A-Z\u0026quot;5行的之字字符:\n1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 8 ... 0 A I Q Y 1 B H J P R X Z 2 C G K O S W 3 D F L N T V 4 E M U 可以看出：\n第0、第4、第8、第12列每行都有字符，其他列只有一个字符 col % (5 - 1) == 0 其他列字符所在行: row = (5 - 1) - (col % (5 - 1)) 字符在输入字符串中的位置(0起)等于: index = col * 2 + row Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 func convert(s string, numRows int) string { /* 0 1 2 3 4 5 6 col * +---------------------- * 0 | 0 x x 6 x x 12 * 1 | 1 x 5 7 x 11 * 2 | 2 4 x 8 10 * 3 | 3 x x 9 * row +---------------------- * * col0: each line have a char * col1: the char is at row2 * col2: the char is at row1 * . * col4: the char is at row2 * * the char is at row( 4 - (col % 3) ) except col0、col0+3、col0+3+3... */ if numRows == 1 { return s } var res string for row := 0; row \u0026lt; numRows; row++ { for col := 0; ; col++ { m := col % (numRows - 1) // if m == 0 there must be a char // else numRows-m eq the char\u0026#39; row-index if m == 0 || row == (numRows - 1) - m{ idx := (col \u0026lt;\u0026lt; 1) + row if idx \u0026gt;= len(s) { break } res += string(s[idx]) } } } return res } ","date":"2017-03-17T17:52:46+08:00","permalink":"https://www.orztu.com/leetcode/006-zigzag-conversion/","title":"LeetCode 6. ZigZag Conversion"},{"content":"Longest Palindromic Substring\nDescription Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\nExample:\n1 2 Input: \u0026#34;babad\u0026#34; Output: \u0026#34;bab\u0026#34; Note: \u0026ldquo;aba\u0026rdquo; is also a valid answer.\nExample:\n1 2 Input: \u0026#34;cbbd\u0026#34; Output: \u0026#34;bb\u0026#34; 从给定字符串中找出最长的回文子串\nSolution 从最大长度开始判断是否回文，是则返回\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func longestPalindrome(s string) string { maxLen := len(s) for l := maxLen; l \u0026gt; 0; l-- { for i := 0; i + l \u0026lt;= maxLen; i++ { lp, rp := i, i + l -1 for lp \u0026lt; rp \u0026amp;\u0026amp; s[lp] == s[rp] { lp++ rp-- } if lp \u0026gt;= rp { return s[i:i+l] } } } return s[0:1] } Similar Problem 3. Longest Substring Without Repeating Characters\n","date":"2017-03-16T14:47:07+08:00","permalink":"https://www.orztu.com/leetcode/005-longest-palindromic-substring/","title":"LeetCode 5. Longest Palindromic Substring"},{"content":"Median of Two Sorted Arrays\nDescription There are two sorted arrays nums1 and nums2 of size m and n respectively.\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\nExample 1:\n1 2 nums1 = [1, 3] nums2 = [2] The median is 2.0\nExample 2:\n1 2 nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5\n从两个有序数组中求中位数\nSolution 通过数组长度，计算中位数的位置。在两个数组中按大小顺序依次查找，找到中位数所在位置，取出数值计算。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { totalLen := len(nums1) + len(nums2) var p1, p2, index1, index2, sum int index1 = int((totalLen - 1) / 2) index2 = int(totalLen / 2) for i := 0; i \u0026lt; totalLen; i++ { if i \u0026gt; index2 { break } var num int if p1 \u0026lt; len(nums1) \u0026amp;\u0026amp; p2 \u0026lt; len(nums2) { if nums1[p1] \u0026lt; nums2[p2] { num = nums1[p1] p1++ } else { num = nums2[p2] p2++ } } else if p1 \u0026lt; len(nums1) { num = nums1[p1] p1++ } else { num = nums2[p2] p2++ } if i == index1 { sum += num } if i == index2 { sum += num } } return float64(sum) / 2.0 } ","date":"2017-03-16T10:53:58+08:00","permalink":"https://www.orztu.com/leetcode/004-median-of-two-sorted-arrays/","title":"LeetCode 4. Median of Two Sorted Arrays"},{"content":"Longest Substring Without Repeating Characters\nDescription Given a string, find the length of the longest substring without repeating characters.\nGiven \u0026ldquo;abcabcbb\u0026rdquo;, the answer is \u0026ldquo;abc\u0026rdquo;, which the length is 3.\nGiven \u0026ldquo;bbbbb\u0026rdquo;, the answer is \u0026ldquo;b\u0026rdquo;, with the length of 1.\nGiven \u0026ldquo;pwwkew\u0026rdquo;, the answer is \u0026ldquo;wke\u0026rdquo;, with the length of 3. Note that the answer must be a substring, \u0026ldquo;pwke\u0026rdquo; is a subsequence and not a substring.\n在给定字符串中找出无重复字符的最长子串。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func lengthOfLongestSubstring(s string) int { l := len(s) maxLen := 0 for p1 := 0; p1 \u0026lt; l; p1++ { m := map[uint8]bool{} for p2 := p1; p2 \u0026lt; l; p2++{ c := s[p2] _, ok := m[c] if ok { break } else { m[c] = true } } if len(m) \u0026gt; maxLen { maxLen = len(m) } } return maxLen } Similar Problem 5. Longest Palindromic Substring\n","date":"2017-03-15T19:38:58+08:00","permalink":"https://www.orztu.com/leetcode/003-longest-substring-without-repeating-characters/","title":"LeetCode 3. Longest Substring Without Repeating Characters"},{"content":"Add Two Numbers\nDescription You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n1 2 Input: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 0 -\u0026gt; 8 给定两个非空链表表示的非负整数。实现加法，向后进位。\nSolution 用一个int作进位寄存器，在下一位相加时加上进位寄存器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { head := \u0026amp;ListNode{} cur := head carry := 0 for { var v1, v2 int if l1 != nil { v1 = l1.Val l1 = l1.Next } if l2 != nil { v2 = l2.Val l2 = l2.Next } v := v1 + v2 + carry carry = int(v / 10) cur.Val = v % 10 if l1 != nil || l2 != nil { cur.Next = \u0026amp;ListNode{} cur = cur.Next } else { if carry \u0026gt; 0 { cur.Next = \u0026amp;ListNode{Val: carry} } break } } return head } ","date":"2017-03-15T16:55:54+08:00","permalink":"https://www.orztu.com/leetcode/002-add-two-numbers/","title":"LeetCode 2. Add Two Numbers"},{"content":"Two Sum\nDescription Given an array of integers, return indices of the two numbers such that they add up to a specific target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n1 2 Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n假定只有唯一解的情况下在数组中找出和为target的两个数\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func twoSum(nums []int, target int) []int { res := make([]int, 2) m := map[int]int{} for i := range nums { m[target - nums[i]] = i } for i := range nums { idx, ok := m[nums[i]] if ok { if i == idx { continue } res[0] = idx res[1] = i sort.Ints(res) break } continue } return res } Similar Problem 15. 3Sum 18. 4Sum 39. Combination Sum 40. Combination Sum II ","date":"2017-03-15T16:36:59+08:00","permalink":"https://www.orztu.com/leetcode/001-two-sum/","title":"LeetCode 1. Two Sum"},{"content":"国际惯例\n","date":"2017-03-14T00:00:00Z","permalink":"https://www.orztu.com/post/hello-world/","title":"Hello World"}]