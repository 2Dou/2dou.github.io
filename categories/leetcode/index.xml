<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on 目不斜视</title>
    <link>http://wa2333.com/categories/leetcode/index.xml</link>
    <description>Recent content in Leetcode on 目不斜视</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="http://wa2333.com/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>3. longest substring without repeating characters</title>
      <link>http://wa2333.com/leetcode/3-longest-substring-without-repeating-characters/</link>
      <pubDate>Wed, 15 Mar 2017 19:38:58 +0800</pubDate>
      
      <guid>http://wa2333.com/leetcode/3-longest-substring-without-repeating-characters/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Given a string, find the length of the longest substring without repeating characters.&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;p&gt;Given &amp;ldquo;abcabcbb&amp;rdquo;, the answer is &amp;ldquo;abc&amp;rdquo;, which the length is 3.&lt;/p&gt;

&lt;p&gt;Given &amp;ldquo;bbbbb&amp;rdquo;, the answer is &amp;ldquo;b&amp;rdquo;, with the length of 1.&lt;/p&gt;

&lt;p&gt;Given &amp;ldquo;pwwkew&amp;rdquo;, the answer is &amp;ldquo;wke&amp;rdquo;, with the length of 3. Note that the answer must be a substring, &amp;ldquo;pwke&amp;rdquo; is a subsequence and not a substring.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;在给定字符串中找出最长子串的长度，子串中不能包含重复字符。&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func lengthOfLongestSubstring(s string) int {
    l := len(s)
    maxLen := 0

    for p1 := 0; p1 &amp;lt; l; p1++ {
        m := map[uint8]bool{}

        for p2 := p1; p2 &amp;lt; l; p2++{
            c := s[p2]

            _, ok := m[c]
            if ok {
                break
            } else {
                m[c] = true
            }
        }

        if len(m) &amp;gt; maxLen {
            maxLen = len(m)
        }
    }

    return maxLen
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>2. add two numbers</title>
      <link>http://wa2333.com/leetcode/2-add-two-numbers/</link>
      <pubDate>Wed, 15 Mar 2017 16:55:54 +0800</pubDate>
      
      <guid>http://wa2333.com/leetcode/2-add-two-numbers/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&lt;/p&gt;

&lt;p&gt;You may assume the two numbers do not contain any leading zero, except the number 0 itself.&lt;/p&gt;

&lt;p&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;/p&gt;

&lt;p&gt;Output: 7 -&amp;gt; 0 -&amp;gt; 8&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;通过链表计算加法，向后进位&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    head := &amp;amp;ListNode{}
    cur := head
    carry := 0

    for {
        var v1, v2 int
        if l1 != nil {
            v1 = l1.Val
            l1 = l1.Next
        }

        if l2 != nil {
            v2 = l2.Val
            l2 = l2.Next
        }

        v := v1 + v2 + carry

        carry = int(v / 10)
        cur.Val = v % 10

        if l1 != nil || l2 != nil {
            cur.Next = &amp;amp;ListNode{}
            cur = cur.Next
        } else {
            if carry &amp;gt; 0 {
                cur.Next = &amp;amp;ListNode{Val: carry}
            }

            break
        }
    }

    return head
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>1. two sum</title>
      <link>http://wa2333.com/leetcode/1-two-sum/</link>
      <pubDate>Wed, 15 Mar 2017 16:36:59 +0800</pubDate>
      
      <guid>http://wa2333.com/leetcode/1-two-sum/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;/p&gt;

&lt;p&gt;You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;/p&gt;

&lt;p&gt;Example:
Given nums = [2, 7, 11, 15], target = 9,&lt;/p&gt;

&lt;p&gt;Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Solution&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func twoSum(nums []int, target int) []int {
    res := make([]int, 2)
    m := map[int]int{}

    for i := range nums {
        m[target - nums[i]] = i
    }

    for i := range nums {
        idx, ok := m[nums[i]]
        if ok {
            if i == idx {
                continue
            }
            res[0] = idx
            res[1] = i
            sort.Ints(res)
            break
        }
        continue
    }

    return res
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>